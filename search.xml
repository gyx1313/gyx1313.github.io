<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javascript中的this，箭头函数中的this]]></title>
    <url>%2Fposts%2Fjavascript%2Fjavascript%E4%B8%AD%E7%9A%84this%EF%BC%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this.html</url>
    <content type="text"><![CDATA[在平常写javascript代码的时候，很多时候我们都需要用到this，不过在根据不同的场景下，this的指向却会有不同的结果。 1234567891011var a = 1;var obj = &#123; a: 2&#125;;function fun() &#123; var a = 3; let f = () =&gt; console.log(this.a); f();&#125;;fun();//1fun.call(obj);//2 如上，fun直接调用，fun的上下文中的this值为window，注意，这个地方有点绕。fun的上下文就是此箭头函数所在的上下文，因此此时f的this为fun的this也就是window。当fun.call(obj)再次调用的时候，新的上下文创建，fun此时的this为obj，也就是箭头函数的this值。 这也就是常说的箭头函数没有自己的this，箭头函数的this实际为其外层函数作用域中的this，可以看到作为箭头函数的f的，他的外层函数是fun，而此时fun作为全局函数调用，那么fun的this就是window，所以f里的this就指向了window了。 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，也就是说箭头函数的this在词法层面就完成了绑定。apply，call方法只是传入参数，却改不了this。 下面再来看下另外一个比较全面的例子。 123456789101112131415161718192021222324252627282930313233var name = &apos;window&apos;var person1 = &#123; name: &apos;person1&apos;, show1: function () &#123; console.log(this.name) &#125;, show2: () =&gt; console.log(this.name), show3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, show4: function () &#123; return () =&gt; console.log(this.name) &#125;&#125;var person2 = &#123; name: &apos;person2&apos; &#125;person1.show1() // person1person1.show1.call(person2) // person2person1.show2() // windowperson1.show2.call(person2) // windowperson1.show3()() // windowperson1.show3().call(person2) // person2person1.show3.call(person2)() // windowperson1.show4()() // person1person1.show4().call(person2) // person1person1.show4.call(person2)() // person2 在一般函数的情况下，this总是指向调用该函数的对象。person1.show1()很好理解，因为是person1对象调用的，所以this也就指向了person1对象，所以结果是person1。而person1.show1.call(person2) 则通过call方法将this指向了person2。 在箭头函数的情况下，person1.show2()的结果却是window，这是因为箭头函数的this指向外层函数作用域中的this，外层函数作用域中的this，实际上这时候并没有外层函数了，外层就是全局环境了，没有外层函数所以指向了window。 person1.show3是一个高阶函数，它返回了一个函数，分步走的话，应该是这样： var func = person3.show() func() 从而导致最终调用函数的执行环境是window，但并不是window对象调用了它。所以说，this总是指向调用该函数的对象，这句话还得补充一句：在全局函数中，this等于window。 person1.show3().call(person2) 与 person1.show3.call(person2)() 也好理解了。前者是通过person2调用了最终的打印方法。后者是先通过person2调用了person1的高阶函数，然后再在全局环境中执行了该打印方法。 person1.show4()()，person1.show4().call(person2)都是打印person1。这好像又印证了那句：箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。因为即使我用过person2去调用这个箭头函数，它指向的还是person1。 然而person1.show4.call(person2)()的结果又是person2。this值又发生改变，看来上述那句描述又走不通了。一步步来分析，先通过person2执行了show4方法，此时show4第一层函数的this指向的是person2。所以箭头函数输出了person2的name。也就是说，箭头函数的this指向的是谁调用箭头函数的外层function，箭头函数的this就是指向该对象，如果箭头函数没有外层函数，则指向window。这样去理解show2方法，也解释的通。 参考：https://juejin.im/post/59748cbb6fb9a06bb21ae36dhttps://juejin.im/post/59aa71d56fb9a0248d24fae3#comment]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS动画中的transform，transition以及animation的区别小结]]></title>
    <url>%2Fposts%2Fcss%2FCSS%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84transform%EF%BC%8Ctransition%E4%BB%A5%E5%8F%8Aanimation%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93.html</url>
    <content type="text"><![CDATA[在css学习中，尤其是动画部分，相信很多人都会接触过transform，transition以及animation属性，如果望文生义从字面上这些词翻译成中文好像都差不多，其实他们三者分别还是很大的。 transform先来看跟变形金刚transformer很像的transform， 首先要注意的是transform属性是静态属性！静态属性！静态属性！只要写进style里就会直接显示生效，不会出现动画过程。通过使用transform属性，能够对元素进行移动（translate）、缩放（scale）、旋转（rotate）、翻转（skew）。对于这些就不展开说，有兴趣的可以自行实践下就明白了。 12345678div&#123;transform: translate(50px,100px) rotate(30deg);-ms-transform: translate(50px,100px) rotate(30deg); /* IE 9 */-webkit-transform: translate(50px,100px) rotate(30deg); /* Safari and Chrome */-o-transform: translate(50px,100px) rotate(30deg); /* Opera */-moz-transform: translate(50px,100px) rotate(30deg); /* Firefox */&#125; transition不同于静态的transform，被称为过渡的transition是一个简单的动画属性，可以看作是是animation的简化版本，通常拿来配合事件触发使用，简单易用。他的语法是transition: property duration timing-function delay;单纯的代码不会触发过渡操作，需要通过用户的行为（如点击，悬浮等）触发，常见的触发的方式有： :hover :focus :checked 媒体查询触发 javascript触发 1234567891011121314div&#123;width:100px;height:100px;background:yellow;transition:width 2s ease-in-out 1.5s;-moz-transition:width 2s ease-in-out 1.5s; /* Firefox 4 */-webkit-transition:width 2s ease-in-out 1.5s; /* Safari and Chrome */-o-transition:width 2s ease-in-out 1.5s; /* Opera */&#125;div:hover&#123;width:300px;&#125; transition的属性 属性 描述 transition-property 执行过渡的css属性 transition-duration 执行过渡的持续时间 transition-timing-function 执行过渡的运动速率曲线 transition-delay 执行过渡的延迟时间 顺带一提transition-property的注意事项，他的可取值如下 none ：没有属性会获得过渡效果。 all ：所有属性都将获得过渡效果。 property ：定义应用过渡效果的 CSS 属性名称列表，以逗号分隔。 不是所有属性都能过渡，只有属性具有一个中间点值才具备过渡效果。完整列表，见这里。 transition的优点在于简单易用，但是它有几个很大的局限。 （1）transition需要事件触发，所以没法在网页加载时自动发生。 （2）transition是一次性的，不能重复发生，除非一再触发。 （3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 （4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。CSS Animation就是为了解决这些问题而提出的。 animation最后来说说最强的animation，animation与keyframes属性搭配使用，有类似flash的概念，animation实现动画效果主要由两部分组成： （1）通过类似Flash动画中的帧来声明一个动画 （2）在animation属性中调用关键帧声明的动画。 关键帧 keyframe 实现自定义动画，通过对关键帧的设定来实现，也就是规定从起始点（0%）到终点（100%）之间的具体节点上的动画样式。就好比一个人起床，睁开眼睛（0%），站起来（10%），穿上衣（40%），穿裤子（80%），整理面容（100%），这样子把每个节点串起来便是动画了。上面提到的transition局限性在于只有两个状态，其实就是相当于只能定义0%和100%。而animation能够自定义任意时间段节点的动画动作。 当在 @keyframes中创建动画时，需要将它捆绑到某个选择器，否则不会产生动画效果。 通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称(animation-name) 规定动画的时长(animation-duration) animation属性类似于transition，都是随着时间改变元素的属性值，其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果。 以下实例为把 “myfirst” 动画捆绑到 div 元素，时长：4 秒，infinite 表示运动次数为无限次，alternate 表示下一周期将逆向地播放。 1234567891011121314151617div&#123;width:100px;height:100px;background:red;animation:myfirst 4s infinite alternate;-moz-animation:myfirst 4s infinite alternate;/* Firefox */-webkit-animation:myfirst 4s infinite alternate; /* Safari and Chrome */-o-animation:myfirst 4s infinite alternate; /* Opera */&#125;@keyframes myfirst&#123;0% &#123;background:red;&#125;50%&#123;background:blue; transform: translate(20px,-20px)&#125;75%&#123;background:green;transform: translate(40px,0px) scale(1.5)&#125;100% &#123;background:yellow;transform: rotate(-45deg)&#125;&#125; 下面的表格列出了 @keyframes 规则和所有动画属性： 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性 animation-name 规定 @keyframes 动画的名称 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的运动速率曲线 animation-delay 规定动画何时开始，默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 animation-fill-mode 规定对象动画时间之外的状态。 参考资料：http://www.w3school.com.cn/css3/css3_animation.asphttp://www.cnblogs.com/aimyfly/p/3195898.htmlhttp://blog.csdn.net/XIAOZHUXMEN/article/details/52003135]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法测试1]]></title>
    <url>%2Fposts%2Fmarkdown%2F%E6%B5%8B%E8%AF%951.html</url>
    <content type="text"><![CDATA[通过在行首插入 1 到 6 个 # (如#大)，来定义对应的 1 到 6 阶 标题： 大大大在 Markdown 中段落由一行或者多行文本组成，相邻的两行文字会被视为同一段落，如果存在空行则被视为不同段落( Markdown 对空行的定义是看起来是空行就是空行，即使空行中存在 空格 TAB 回车 等不可见字符，同样会被视为空行 )。 第一行 两行之间存在空行，视为不同段落。 链接的语法为[链接名称]然后紧跟（链接） 豆瓣 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://www.douban.com 图片的语法为![图片名称]然后紧跟（图片链接） 倾斜粗体 删除线 这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字 项目 项目 项目 子项目 子项目 项目 * 项目 项目 项目 子项目 子项目 项目 * 列表 属性 描述 苹果 红色 香蕉 黄色 葡萄 紫色 *Hi* 一句话行内代码一句话。 多行代码使用 3 个反引号来标记(反引号一般位于键盘左上角，要用英文) ，在第一个 ｀｀｀ 后面可以跟语言类型，没有语言类型可以省略不写: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export default &#123; [type.ADDEVENT](states, obj)&#123; states.count++; obj.items.id = states.count; states.event.unshift(obj.items); func.local.set(states); &#125;, [type.EVENTDONE](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 2; states.event[i].time = func.getDate(); var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.EVENTTODO](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 1; var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.EVENTCANCEL](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 3; var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.CLEAREVENT](states)&#123; states.event = []; func.local.clear(); &#125;, [type.DELEVENT](states, info)&#123; if (states.event[info.index].id === info.id) &#123; states.event.splice(info.index, 1); &#125; else &#123; states.event.filter(function (d, i) &#123; if (d.id == info.id) &#123; states.event.splice(i, 1); &#125; &#125;) &#125; func.local.set(states); &#125;, [type.EDITEVENT](states, info)&#123; if (states.event[info.index].id === info.id) &#123; states.event[info.index].content = info.content; &#125; else &#123; states.event.filter(function (d) &#123; if (d.id == info.id) &#123; d.content = info.content; &#125; &#125;) &#125; func.local.set(states); &#125;&#125; 1$ hexo new "My New Post"]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>