<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[作用域与闭包详解]]></title>
    <url>%2Fposts%2Fjavascript%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[函数作用域执行环境(execution context)是js中最为重要的一个概念，执行环境定义了变量或者函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围的一个执行环境，在web浏览器中，全局执行函数被认为是window对象，因此所有全局变量和函数都作为window对象的属性和方法创建的。某个执行环境中所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。全局执行环境直到应用程序退出也随之销毁(关闭网页和浏览器的时候)。(引自《javascript高级编程第四章73页》)。 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在一开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境；全局执行环境始终是作用域链中的最后一个对象。 123456function galaxy () &#123; function solar () &#123; var earth = &apos;i am blue star&apos; &#125;&#125; 可以看到earth变量是在solar执行环境中，而solar又是在galaxy的执行环境中，earth的作用域链就是从solar-&gt;galaxy-&gt;window 全局作用域12345678var hello = &apos;Hello Trump!&apos;function sayHello () &#123; console.log(hello)&#125;console.log(hello) // &apos;Hello Trump!&apos;sayHello() // &apos;Hello Trump!&apos; 一旦声明了一个全局变量，那么在任何地方都可以使用它，包括函数内部。 局部作用域1234567function sayHello () &#123; var hello = &apos;Hello Trump!&apos; console.log(hello)&#125;sayHello() // &apos;Hello Trump!&apos;console.log(hello) // Error, hello is not defined 在这里hello是在sayHello函数中的局部变量，只存在于该局部作用域内，因此在函数外无法访问。 总结：在ES6之前，js的作用域只有两种： 1、 全局作用域； 2、 函数作用域。 作用域分为局部作用域和全局作用域。有如下几种情况可归纳为全局作用域： ①最外层函数和在最外层函数外面定义的变量拥有全局作用域。 ②所有末定义直接赋值的变量自动声明为拥有全局作用域。 ③所有window对象的属性拥有全局作用域。而局部作用域：是函数内部的作用域，一般只在固定的代码片段内可访问到，有时候也成为函数作用域。这里引申一下变量的搜索机制：先搜索局部变量，如果没找到，往上一层查找，直到搜索全部变量，如果都没找到，返回undefined。 变量提升/函数提升变量提升/函数提升,顾名思义,就是把定义在后面的变量或者函数,提升到前面来使用。1234567891011// 此段代码实际等同下段sayHello()function sayHello () &#123; console.log(&apos;Hello Trump!&apos;)&#125;// 此段代码实际等同上段function sayHello () &#123; console.log(&apos;Hello Trump!&apos;)&#125;sayHello() 要记住的是，只有函数声明才存在函数提升，如果是像下面那样使用函数表达式来定义，函数就不会被提升到变量作用域的顶部。 1234sayHello() // Error, sayHello is not definedvar sayHello = function () &#123; console.log(aFunction)&#125; 再来看下变量提升。12345678910console.log(global); // undefinedvar global = &apos;global&apos;;console.log(global); // global function fn () &#123; console.log(a); // undefined var a = &apos;aaa&apos;; console.log(a); // aaa&#125;fn(); 由于js的变量提升，实际上上面的代码是按照以下来执行的 123456789101112var global; // 变量提升，全局作用域范围内，此时只是声明，并没有赋值console.log(global); // undefinedglobal = &apos;global&apos;; // 此时才赋值console.log(global); // 打印出global function fn () &#123; var a; // 变量提升，函数作用域范围内 console.log(a); a = &apos;aaa&apos;; console.log(a);&#125;fn(); 块级作用域前面说到在ES6之前，js的作用域只有全局作用域和函数局部作用域两种东西，而缺少了块级作用域。啥是块级作用域呢？花括号封闭的代码块就是块级作用域。1234if(true) &#123; var color = &quot;blue&quot;;&#125;alert(color); // blue 这里是在一个if语句中定义了变量color，如果是在C、C++或Java中，color 会在if 语句之行完毕后被销毁，后面将会是alert不出color的。但在javascript中，if语句中的变量声明会将变量添加到当前的执行环境(在这个例子中是全局环境)中。 ES6的块级作用域let但是！在ES6中，新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面再来看下经典的案例！下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是用var命令声明的，还记得前面提过的，因为javascript没有块级作用域，变量声明会将变量添加到当前的执行环境！在这里var声明的变量就变成了一个全局变量，跟a平起平坐，在全局范围内都有效了！ 然鹅很不幸的是，全局又只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，根据作用域链的原则，因为在里面的这个匿名函数内也没有一个叫i的局部变量，所以里面的i只好向上一层，最后指向就是前面那个全局的i了。也就是说，所有数组a的成员里面的i，指向的都是同一个i，到最后循环结束时，i的值已经是10，所以运行时输出的都是指向最后一轮的i的值，也就是10。所以结论就是都是var惹的祸啊！ 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，跟上面最大的不同就是，这里每一轮的i可以看成是一个局部变量，而没有像上面那样坑爹变成一个全局变量！里面的这个匿名函数每一轮都会指向当前这一轮的i的值。每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升 var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // &quot;undefined&quot; 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 为什么需要块级作用域？ ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，也就是上面介绍let时的例子，用来计数的循环变量泄露为全局变量。 1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 const除了let以外，新增的const声明一个只读的常量。一旦声明，常量的值就不能改变。const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = &quot;Hello!&quot;;let age = 25;// 以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30; 本质 重点来了！const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push(&apos;Hello&apos;); // 可执行a.length = 0; // 可执行a = [&apos;Dave&apos;]; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 总结：可以看到，let和const是对var的一个更完善的补充，那么问题来了，什么时候用let什么时候用const什么时候用var呢? let、const在任何情况下都优于var！所以没啥事就不要用var了！ const用于声明常量，一般用于不可以被重新赋值的变量。 而let是定义普通的变量。 大部分情况下const的出场率比let高很多，所以一般建议默认使用const，除非一定要改变变量的值，再使用let。 说白了，赋值之后不会再做修改了就用const，如果后边还会修改就用let，总之不建议使用var。 参考http://www.zcfy.cc/article/javascript-scope-and-closures-css-tricks-4107.html?t=new http://www.cnblogs.com/giggle/archive/2016/06/13/5572006.html https://segmentfault.com/q/1010000000375714 https://www.zhihu.com/question/22786933 http://www.cnblogs.com/aaronjs/articles/2167431.html http://blog.csdn.net/tyro_java/article/details/51137776 http://www.cnblogs.com/zhangxiaos/p/6215420.html http://es6.ruanyifeng.com/#docs/let http://www.cnblogs.com/ziyunfei/p/6038213.html https://www.zhihu.com/question/51820539 https://segmentfault.com/q/1010000005079405 闭包什么是闭包 简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。为什么需要闭包呢？ 局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。 占用更多内存 不容易被释放 何时使用？ 既想反复使用，又想避免全局污染。 在一个函数内新建另一个函数时，就相当于创建了一个闭包。内层函数就是闭包。通常情况下，为了能够使得外部函数的内部变量可以访问，一般都会返回这个闭包。 12345678910function outerFunc () &#123; const outer = &apos;I see the outer variable.&apos; function innerFunc () &#123; console.log(outer) &#125; return innerFunc&#125;outerFunc()() // I see the outer variable. 因为内部函数是返回值，因此你可以简化函数声明的部分： 123456789function outerFunc () &#123; const outer = `I see the outer variable!` return function innerFunc() &#123; console.log(outer) &#125;&#125;outerFunc()() // I see the outer variable! 再来看看前面的for循环例子 1234567891011121314151617181920// 闭包改造前var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10// 闭包改造后var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = (function (i)&#123; return function ()&#123; console.log(i) &#125; &#125;)(i)&#125;a[6](); // 6 修改之后的版本中，arr数组每次添加新项是都会使得自执行函数执行，并将i作为实参传入了自执行函数，关键点是 function(i){…}(i)中第一个i是函数的形参，是私有变量，与外面的i没有关系，被私有作用域保护起来了，第二个i才是函数中外面的i（也就是说第一个i只是一个迷惑人的量，你改成k也是一样的结果，只不过是把i赋给k而已），这样一来，每次触发自执行函数时，都相当于将当前循环的变量i存储了下来。当arr中每一项执行时，调用了自执行函数返回的一个新地址的函数，也就是被return出来的里层函数，这个新地址的函数会去上级作用域去寻找i，上级作用域是形成这个新地址时的自执行函数，上级作用域中的i（或者说是上级作用域中那个形参）就是他要找的i。这种保护私有变量的机制就是闭包。 关键点在以下 JavaScript传参是传的复制值不是引用值，也就是我执行的时候 i 是啥我就alert啥 第一段代码中并不是传参，只是在函数内部引用了i变量。 第二段代码是把 i 作为参数传到了函数里，函数内部会复制传进来的 i 的值（参见第一条），然后再存到数组里。 因此，第一段代码中在执行函数的时候， i 已经在for循环中变为3，alert出来就是3，而第二段代码中函数数组中的函数因为参数都是复制的不同的i，所以每个包含的参数都是不同的，因此也就能够输出0,1,2,3。 参考https://www.zhihu.com/question/33468703]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 高级手册读书笔记01:数据类型]]></title>
    <url>%2Fposts%2Fjavascript%2FJavascript-%E9%AB%98%E7%BA%A7%E6%89%8B%E5%86%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B001-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[数据类型javascript中有五种简单数据类型（基本数据类型）：Undefined, Null, String, Number, Boolean。一种复杂数据类型（引用数据类型）：Object。 javascript中的变量是松散类型（即弱类型）的，可以用来保存任何类型的数据。 可以用typeof 操作符去检测给定变量的数据类型，可能的返回值： ‘undefined’ — 这个值未定义； ‘boolean’ — 这个值是布尔值； ‘string’ — 这个值是字符串； ‘number’ — 这个值是数值； ‘object’ — 这个值是对象或null； ‘function’ — 这个值是函数。 typeof 有不少的坑，比如： 1typeof null // &quot;object&quot; 因为特殊值null会被认为是一个空的对象引用，因此会得到这样的结果。所以严格来说typeof只能笼统地检测出数据类型，大多数情况下不建议使用，后面继续说更好的方法 Undefined 类型Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个值就是undefined。 12var messageconsole.log(typeof message) // &apos;undefined&apos; Null 类型Null类型和Undefined一样，也是只有一个值，即特殊的null。null值表示的是一个空的对象指针，这也就是typeof null会得到”object”的原因。 12var car = nullconsole.log(typeof car) // &apos;null&apos; 所以可以理解为Null是针对对象版的Undefined，要是定义了一个新的变量是准备拿来保存对象的，那么最好将其初始化为null而不是其他值，这样比较直观。另外要说一下，如果做比较: 12console.log(null == undefined) // trueconsole.log(null === undefined) // false 这也算是一个小坑，怪不得eslint要求无论什么时候都用”===”，因为”==”会帮我们类型转换，有时候需要准确结果的话，不见得是好事。 Boolean 类型Boolean类型是JavaScript中的一种原始类型，它只有两种值：true和false。 使用Boolean(value)方法可以强制转换任意值为boolean类型。 12345678alert(Boolean(&apos;&apos;)); //outpt false alert(Boolean(&apos;hello&apos;)); //output true alert(Boolean(100)); //output true alert(Boolean(0)); //output falsealert(Boolean(NaN)); //output falsealert(Boolean(null)); //output false alert(Boolean(undefined)); //output false alert(Boolean(new Object())); //output true 可以看出，当被转换的值为空字符串、数字0和NaN、null或者undefined时，转换为false，其它情况转换为true。所以当我们写if判断的时候需要注意这些特殊的情况，尤其是使用目前比较流行的“对象探测法”书写JS时。 1234567var student = new Object(); if (student.name) &#123; alert(student.name); &#125; else &#123; student.name = &apos;Tom&apos;; alert(student.name); &#125; if (student.name)这句用来探测student对象中存不存在name属性，如果存在则弹出；否则把name赋值为’Tom’，再弹出。这边需要注意的是如果name值已经存在，并且值为空字符串或者0时，结果可能与你预期的不同。 参考：http://blog.csdn.net/gudanyehai/article/details/6089255 Number 类型关于Number类型先占个坑，粗略要说下的是要记住八进制这个坑，还有浮点数大坑。。 NaNNaN(Not a Number)是Number类型的一个特殊值，这个数值表示一个本来要返回数值的操作数未返回数值的情况。比如，任何数除以0会返回NaN，另外，任何涉及NaN的操作，例如（NaN/10）都会返回NaN，NaN与任何值都不相等，包括NaN自身，这意味着（NaN == NaN）将返回 false。 针对这个如此特殊的值，规范中有了isNaN() 这个函数，用于检查其参数是否是非数字值。 12345alert(isNaN(NaN)) // truealert(isNaN(10)) // false （10是一个数值）alert(isNaN(&apos;10&apos;)) // false （可以被转换成数值10）alert(isNaN(&apos;blue&apos;)) // true （不能被转换成数值）alert(isNaN(true)) // false （可以被转换成数值1） 数值转换再次占个坑，有三个函数可以把非数值转换为数值，分别是：Number()、parseInt()和parseFloat()。第一个函数，Number()可以用于任何数据类型，而另外两个函数则专门用于把字符串转换成数值。 String 类型Object 类型前面提及的都是基本数据类型，Object数据类型是复杂数据类型。 类型判断typeof 和 instanceof在javascript中，typeof 和 instanceof 是用来判断数据类型比较通用的两个方法，这篇文章的目的是通过对这两个方法介绍来分析其存在的不足并提出优化方案。 typeoftypeof 返回一个表达式的数据类型的字符串，返回结果为javascript中的基本数据类型，包括：number、boolean、string、object、undefined、function等6种数据类型。 12345678typeof 100; //numbertypeof (1==1); //booleantypeof &apos;onepixel&apos;; //stringtypeof &#123;&#125; ; //objecttypeof onepixel; // undefinedtypeof parseInt; // functiontypeof [];//objecttypeof new Date(); //object 可以看出，typeof 可以准确的判断除object以外的基础数据类型，但不能区分object类型的具体类型，比如 Array 、Date 以及自定义类。 instanceofinstanceof 本意是用来判断 A 是否为 B 的实例对象，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：instanceof检测的是原型，那它是怎么检测的呢，我们用一段伪代码来模拟其内部执行过程： 123456789instanceof (A,B) = &#123;var L = A.__proto__;var R = B.prototype;if(L === R) &#123;//A的内部属性__proto__指向B的原型对象return true;&#125;return false;&#125; 从上述过程可以看出，当A的proto 指向B的prototype时，就认为A就是B的实例对象，我们再来看几个例子： 12345678[] instanceof Array; //true&#123;&#125; instanceof Object;//truenew Date() instanceof Date;//truefunction Person()&#123;&#125;;new Person() instanceof Person;[] instanceof Object; //truenew Date() instanceof Object;//trunew Person instanceof Object;//true 从上面的例子中，我们发现虽然instanceof能够正确判断[] 是Array的实例对象，但不能辨别 [] 不是Object的实例对象，为什么呢，这还需要从javascript的原型链说起，我们首先来分析一下[]、Array、Object 三者之间的关系，从instanceof判断能够得出：[].proto -&gt;Array.prototype， 而Array.prototype.proto指向了Object.prototype，Object.prototype.proto 指向了null,标志着原型链的结束。（ps:关于JS原型链请阅读：浅谈javascript原型和原型链） 因此，[]、Array、Object就形成了一条原型链： 从原型链可以看出，[]的proto最终指向了Object.prototype，类似的new Date()、new Person() 也会形成这样一条原型链，因此，我们用 instanceof 也不能完全精确的判断object类的具体数据类型。 参考：http://www.jb51.net/article/77948.htm Object.prototype.toString()在 JavaScript 里使用 typeof 来判断数据类型，只能区分基本类型，即 “number”，”string”，”undefined”，”boolean”，”object” 五种。 对于数组、函数、对象来说，其关系错综复杂，使用 typeof 都会统一返回 “object” 字符串。 要想区别对象、数组、函数单纯使用 typeof 是不行的，JavaScript中,通过Object.prototype.toString方法，判断某个对象值属于哪种内置类型。 1.判断基本类型： 12345Object.prototype.toString.call(null);//”[object Null]”Object.prototype.toString.call(undefined);//”[object Undefined]”Object.prototype.toString.call(“abc”);//”[object String]”Object.prototype.toString.call(123);//”[object Number]”Object.prototype.toString.call(true);//”[object Boolean]” 2.判断原生引用类型：函数类型 12Function fn()&#123;console.log(“test”);&#125;Object.prototype.toString.call(fn);//”[object Function]” 日期类型 12var date = new Date();Object.prototype.toString.call(date);//”[object Date]” 数组类型 12var arr = [1,2,3];Object.prototype.toString.call(arr);//”[object Array]” 正则表达式 12var reg = /[hbc]at/gi;Object.prototype.toString.call(arr);//”[object Array]” 自定义类型 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person(&quot;Rose&quot;, 18);Object.prototype.toString.call(person); //”[object Object]” 但是要注意的一点是，如果是自定义类型，则是还是需要用instanceof去判断很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示： 1console.log(person instanceof Person);//输出结果为true 参考：http://blog.csdn.net/icanlove/article/details/43702879 http://www.cnblogs.com/youhong/p/6209054.html http://www.cnblogs.com/ziyunfei/archive/2012/11/05/2754156.html http://www.cnblogs.com/wyaocn/p/5796142.html https://juejin.im/post/59b5540c5188257e8769e95d#comment]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>基础概念</tag>
        <tag>Javascript高级手册读书笔记</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的this，箭头函数中的this]]></title>
    <url>%2Fposts%2Fjavascript%2Fjavascript%E4%B8%AD%E7%9A%84this%EF%BC%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this.html</url>
    <content type="text"><![CDATA[在平常写javascript代码的时候，很多时候我们都需要用到this，不过在根据不同的场景下，this的指向却会有不同的结果。 1234567891011var a = 1;var obj = &#123; a: 2&#125;;function fun() &#123; var a = 3; let f = () =&gt; console.log(this.a); f();&#125;;fun();//1fun.call(obj);//2 如上，fun直接调用，fun的上下文中的this值为window，注意，这个地方有点绕。fun的上下文就是此箭头函数所在的上下文，因此此时f的this为fun的this也就是window。当fun.call(obj)再次调用的时候，新的上下文创建，fun此时的this为obj，也就是箭头函数的this值。 这也就是常说的箭头函数没有自己的this，箭头函数的this实际为其外层函数作用域中的this，可以看到作为箭头函数的f的，他的外层函数是fun，而此时fun作为全局函数调用，那么fun的this就是window，所以f里的this就指向了window了。 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，也就是说箭头函数的this在词法层面就完成了绑定。apply，call方法只是传入参数，却改不了this。 下面再来看下另外一个比较全面的例子。 123456789101112131415161718192021222324252627282930313233var name = &apos;window&apos;var person1 = &#123; name: &apos;person1&apos;, show1: function () &#123; console.log(this.name) &#125;, show2: () =&gt; console.log(this.name), show3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, show4: function () &#123; return () =&gt; console.log(this.name) &#125;&#125;var person2 = &#123; name: &apos;person2&apos; &#125;person1.show1() // person1person1.show1.call(person2) // person2person1.show2() // windowperson1.show2.call(person2) // windowperson1.show3()() // windowperson1.show3().call(person2) // person2person1.show3.call(person2)() // windowperson1.show4()() // person1person1.show4().call(person2) // person1person1.show4.call(person2)() // person2 在一般函数的情况下，this总是指向调用该函数的对象。person1.show1()很好理解，因为是person1对象调用的，所以this也就指向了person1对象，所以结果是person1。而person1.show1.call(person2) 则通过call方法将this指向了person2。 在箭头函数的情况下，person1.show2()的结果却是window，这是因为箭头函数的this指向外层函数作用域中的this，外层函数作用域中的this，实际上这时候并没有外层函数了，外层就是全局环境了，没有外层函数所以指向了window。 person1.show3是一个高阶函数，它返回了一个函数，分步走的话，应该是这样：123var func = person3.show()func() 从而导致最终调用函数的执行环境是window，但并不是window对象调用了它。所以说，this总是指向调用该函数的对象，这句话还得补充一句：在全局函数中，this等于window。 person1.show3().call(person2) 与 person1.show3.call(person2)() 也好理解了。前者是通过person2调用了最终的打印方法。后者是先通过person2调用了person1的高阶函数，然后再在全局环境中执行了该打印方法。 person1.show4()()，person1.show4().call(person2)都是打印person1。这好像又印证了那句：箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。因为即使我用过person2去调用这个箭头函数，它指向的还是person1。 然而person1.show4.call(person2)()的结果又是person2。this值又发生改变，看来上述那句描述又走不通了。一步步来分析，先通过person2执行了show4方法，此时show4第一层函数的this指向的是person2。所以箭头函数输出了person2的name。也就是说，箭头函数的this指向的是谁调用箭头函数的外层function，箭头函数的this就是指向该对象，如果箭头函数没有外层函数，则指向window。这样去理解show2方法，也解释的通。 参考：https://juejin.im/post/59748cbb6fb9a06bb21ae36dhttps://juejin.im/post/59aa71d56fb9a0248d24fae3]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS动画中的transform，transition以及animation的区别小结]]></title>
    <url>%2Fposts%2Fcss%2FCSS%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84transform%EF%BC%8Ctransition%E4%BB%A5%E5%8F%8Aanimation%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93.html</url>
    <content type="text"><![CDATA[在css学习中，尤其是动画部分，相信很多人都会接触过transform，transition以及animation属性，如果望文生义从字面上这些词翻译成中文好像都差不多，其实他们三者分别还是很大的。 transform先来看跟变形金刚transformer很像的transform， 首先要注意的是transform属性是静态属性！静态属性！静态属性！只要写进style里就会直接显示生效，不会出现动画过程。通过使用transform属性，能够对元素进行移动（translate）、缩放（scale）、旋转（rotate）、翻转（skew）。对于这些就不展开说，有兴趣的可以自行实践下就明白了。 12345678div&#123;transform: translate(50px,100px) rotate(30deg);-ms-transform: translate(50px,100px) rotate(30deg); /* IE 9 */-webkit-transform: translate(50px,100px) rotate(30deg); /* Safari and Chrome */-o-transform: translate(50px,100px) rotate(30deg); /* Opera */-moz-transform: translate(50px,100px) rotate(30deg); /* Firefox */&#125; transition不同于静态的transform，被称为过渡的transition是一个简单的动画属性，可以看作是是animation的简化版本，通常拿来配合事件触发使用，简单易用。他的语法是transition: property duration timing-function delay;单纯的代码不会触发过渡操作，需要通过用户的行为（如点击，悬浮等）触发，常见的触发的方式有： :hover :focus :checked 媒体查询触发 javascript触发 1234567891011121314div&#123;width:100px;height:100px;background:yellow;transition:width 2s ease-in-out 1.5s;-moz-transition:width 2s ease-in-out 1.5s; /* Firefox 4 */-webkit-transition:width 2s ease-in-out 1.5s; /* Safari and Chrome */-o-transition:width 2s ease-in-out 1.5s; /* Opera */&#125;div:hover&#123;width:300px;&#125; transition的属性 属性 描述 transition-property 执行过渡的css属性 transition-duration 执行过渡的持续时间 transition-timing-function 执行过渡的运动速率曲线 transition-delay 执行过渡的延迟时间 顺带一提transition-property的注意事项，他的可取值如下 none ：没有属性会获得过渡效果。 all ：所有属性都将获得过渡效果。 property ：定义应用过渡效果的 CSS 属性名称列表，以逗号分隔。 不是所有属性都能过渡，只有属性具有一个中间点值才具备过渡效果。完整列表，见这里。 transition的优点在于简单易用，但是它有几个很大的局限。 （1）transition需要事件触发，所以没法在网页加载时自动发生。 （2）transition是一次性的，不能重复发生，除非一再触发。 （3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 （4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。CSS Animation就是为了解决这些问题而提出的。 animation最后来说说最强的animation，animation与keyframes属性搭配使用，有类似flash的概念，animation实现动画效果主要由两部分组成： （1）通过类似Flash动画中的帧来声明一个动画 （2）在animation属性中调用关键帧声明的动画。 关键帧 keyframe 实现自定义动画，通过对关键帧的设定来实现，也就是规定从起始点（0%）到终点（100%）之间的具体节点上的动画样式。就好比一个人起床，睁开眼睛（0%），站起来（10%），穿上衣（40%），穿裤子（80%），整理面容（100%），这样子把每个节点串起来便是动画了。上面提到的transition局限性在于只有两个状态，其实就是相当于只能定义0%和100%。而animation能够自定义任意时间段节点的动画动作。 当在 @keyframes中创建动画时，需要将它捆绑到某个选择器，否则不会产生动画效果。 通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称(animation-name) 规定动画的时长(animation-duration) animation属性类似于transition，都是随着时间改变元素的属性值，其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果。 以下实例为把 “myfirst” 动画捆绑到 div 元素，时长：4 秒，infinite 表示运动次数为无限次，alternate 表示下一周期将逆向地播放。 1234567891011121314151617div&#123;width:100px;height:100px;background:red;animation:myfirst 4s infinite alternate;-moz-animation:myfirst 4s infinite alternate;/* Firefox */-webkit-animation:myfirst 4s infinite alternate; /* Safari and Chrome */-o-animation:myfirst 4s infinite alternate; /* Opera */&#125;@keyframes myfirst&#123;0% &#123;background:red;&#125;50%&#123;background:blue; transform: translate(20px,-20px)&#125;75%&#123;background:green;transform: translate(40px,0px) scale(1.5)&#125;100% &#123;background:yellow;transform: rotate(-45deg)&#125;&#125; 下面的表格列出了 @keyframes 规则和所有动画属性： 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性 animation-name 规定 @keyframes 动画的名称 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的运动速率曲线 animation-delay 规定动画何时开始，默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 animation-fill-mode 规定对象动画时间之外的状态。 参考资料：http://www.w3school.com.cn/css3/css3_animation.asphttp://www.cnblogs.com/aimyfly/p/3195898.htmlhttp://blog.csdn.net/XIAOZHUXMEN/article/details/52003135]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法测试1]]></title>
    <url>%2Fposts%2Fmarkdown%2F%E6%B5%8B%E8%AF%951.html</url>
    <content type="text"><![CDATA[通过在行首插入 1 到 6 个 # (如#大)，来定义对应的 1 到 6 阶 标题： 大大大在 Markdown 中段落由一行或者多行文本组成，相邻的两行文字会被视为同一段落，如果存在空行则被视为不同段落( Markdown 对空行的定义是看起来是空行就是空行，即使空行中存在 空格 TAB 回车 等不可见字符，同样会被视为空行 )。 第一行 两行之间存在空行，视为不同段落。 链接的语法为[链接名称]然后紧跟（链接） 豆瓣 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://www.douban.com 图片的语法为![图片名称]然后紧跟（图片链接） 倾斜粗体 删除线 这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字 项目 项目 项目 子项目 子项目 项目 * 项目 项目 项目 子项目 子项目 项目 * 列表 属性 描述 苹果 红色 香蕉 黄色 葡萄 紫色 *Hi* 一句话行内代码一句话。 多行代码使用 3 个反引号来标记(反引号一般位于键盘左上角，要用英文) ，在第一个 ｀｀｀ 后面可以跟语言类型，没有语言类型可以省略不写: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export default &#123; [type.ADDEVENT](states, obj)&#123; states.count++; obj.items.id = states.count; states.event.unshift(obj.items); func.local.set(states); &#125;, [type.EVENTDONE](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 2; states.event[i].time = func.getDate(); var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.EVENTTODO](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 1; var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.EVENTCANCEL](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 3; var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.CLEAREVENT](states)&#123; states.event = []; func.local.clear(); &#125;, [type.DELEVENT](states, info)&#123; if (states.event[info.index].id === info.id) &#123; states.event.splice(info.index, 1); &#125; else &#123; states.event.filter(function (d, i) &#123; if (d.id == info.id) &#123; states.event.splice(i, 1); &#125; &#125;) &#125; func.local.set(states); &#125;, [type.EDITEVENT](states, info)&#123; if (states.event[info.index].id === info.id) &#123; states.event[info.index].content = info.content; &#125; else &#123; states.event.filter(function (d) &#123; if (d.id == info.id) &#123; d.content = info.content; &#125; &#125;) &#125; func.local.set(states); &#125;&#125; 1$ hexo new "My New Post"]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>