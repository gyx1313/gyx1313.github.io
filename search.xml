<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解javascript 中的原型和原型链还有继承]]></title>
    <url>%2Fposts%2Fjavascript%2F%E7%90%86%E8%A7%A3javascript-%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.html</url>
    <content type="text"><![CDATA[理解对象创建自定义对象最简单的方式就是创建一个Object实例，然后为它添加属性和方法，下面例子是使用Object构造函数创建一个对象： 1234567const person = new Object()person.name = &apos;Trump&apos;person.age = 71person.job = &apos;President&apos;person.sayName = function () &#123; console.log(this.name)&#125; 上面的例子用对象字面量语法可以写成这样： 12345678const person = &#123; name: &apos;Trump&apos;, age: 71， job: &apos;President&apos;, sayName: function () &#123; console.log(this.name) &#125;&#125; 创建对象虽然Object 构造函数或对象字面量都可以创建单个对象，但是有个明显缺点：使用同一个接口创建很多对象，会产生大量重复代码。为了解决这个问题，人们开始使用工厂模式的一种变体。 工厂模式工厂模式抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节，如下所示： 12345678910111213function createPerson (name, age, job) &#123; const o = new Object() o.name = name o.age = age o.job = job o.sayName = function () &#123; console.log(this.name) &#125; return o&#125;const person1 = createPerson(&apos;Trump&apos;, 71, &apos;President&apos;)const person2 = creatPerson(&apos;Bieber&apos;, 23, &apos;wtf&apos;) 函数createPerson() 根据接受的参数来构建一个包含所有必要信息的Person对象。可以无数次调用这个函数，每次都返回一个包含三个属性和一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但是没有解决对象识别的问题（即如何知道一个对象的类型）。 构造函数模式创建自定义的构造函数，从而定义自定义对象类型的属性和方法。可以使用构造函数模式将上面例子改写成如下： 1234567891011function Person (name, age, job) &#123; this.name = name this.age = age this.job = job this.sayName = function () &#123; console.log(this.name) &#125; &#125;const person1 = new Person(&apos;Trump&apos;, 71, &apos;President&apos;)const person2 = new Person(&apos;Bieber&apos;, 23, &apos;wtf&apos;) Person() 函数与前面的 createPerson() 相比，有以下不同： 没有显式地创建对象 直接将属性和方法赋给了this对象 没有return 语句 此外，函数名Person 用的是大写字母P，按照规范，构造函数要以大写字母开头，而非构造函数则以小写字母开头，方便一眼能够以示区分。构造函数本身也是函数，只不过可以用来创建对象。 创建Person的新实例，必须使用new 操作符，这种方式调用构造函数实际上经历的是以下过程： 创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数的代码（为这个新对象添加属性） 返回新对象 person1 和person2 分别保存着Person 的一个不同的实例，这两个对象都有一个constructor（构造函数）属性，这个属性指向Person。 12console.log(person1.constructor == Person) // trueconsole.log(person2.constructor == Person) // true 对象的constructor 属性最初是用来标识对象类型的，如果要检测对象类型，可以用instanceof 操作符。在例子中，所有对象既是Object 的实例，也是Person 的实例： 12console.log(person1 instanceof Person) // trueconsole.log(person1 instanceof Object) // true 创建自定义构造函数意味着将来可以将它的实例标识为一种特定的类型，而正是构造函数模式比工厂模式更好的地方。person1 和person2 都是Object 的实例，所有对象都是继承自Object。 构造函数的主要问题，是每个方法都要在实例上重新创建一遍。前面例子中，person1 和person2 都有一个名为sayName() 的方法，但两个方法却不是同一个Function 的实例。javascript中，函数即是对象，因此每定义一个函数，就是实例化了一个对象，前面的例子实际上是与以下代码等价的： 123456function Person (name, age, job) &#123; this.name = name this.age = age this.job = job this.name = new Function (&apos;console.log(this.name)&apos;)&#125; 从这个例子能够更容易明白每个Person 的实例都包含一个不同的Function 实例的本质。所以不同实例上的同名函数是不相等的。 1console.log(person1.sayName == person2.sayName) // false 创建两个完成同样任务的Function 实例实在是种浪费，所以我们可以利用原型去解决这个问题。 原型模式每个函数都有一个prototype(原型) 属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按字面意思理解，prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。也就是不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中： 123456789101112131415function Person () &#123;&#125;Person.prototype.name = &apos;Trump&apos;Person.prototype.age = 71Person.prototype.job = &apos;President&apos;Person.prototype.sayName = function () &#123; console.log(this.name)&#125;const person1 = new Person()person1.sayName() // &apos;Trump&apos;const person2 = new Person()person2.sayName() // &apos;Trump&apos;console.log(person1.sayName == person2.sayName) // true 将sayName() 方法和所有属性添加到了Person 的prototype 属性中，即使构造函数是个空函数，也可以通过调用构造函数来创建新对象，而且新对象还具有相同的属性和方法。并且新对象的这些属性和方法是由所有实例共享的。 理解原型对象只要创建了一个新函数，该函数就会自动带有prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向指向prototype 所在函数的指针。 创建自定义的构造函数后，其原型对象默认只带有constructor 属性，其他的方法则都是从Object 继承而来的。调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性__proto__，也就是所谓的隐式原型(注：图里的[[Prototype]]实际上就是__proto__) 总结： __proto__ （隐式原型）属性属于对象，prototpye（显式原型）属性属于构造函数。 上图展示了Person 构造函数、Person 的原型属性以及Person现有的两个实例之间的关系。Person.prototype 指向了原型对象，而Person.prototype.constructor 又指回了Person。原型对象中除了包含constructor 属性之外，还包括后来添加的其他属性。Person 的每个实例person1 和person2 都包含一个内部属性，该属性仅仅指向了Person.prototype。换句话说，它们与构造函数没有直接的关系。此外，要注意的是，虽然这两个实例都不包含属性和方法，但却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。 虽然在所有实现中都无法访问到__proto__ ，但可以通过isPrototypeOf() 方法来确定对象之间是否存在这种关系。从本质上讲，如果__proto__ 指向调用isPrototypeOf() 方法的对象（Person.prototype），那么这个方法就返回true，如下所示： 12console.log(Person.prototype.isPrototypeOf(person1)) // trueconsole.log(Person.prototype.isPrototypeOf(person2)) // true 这里，我们用原型对象的isPrototypeOf() 方法测试了person1 和person2。因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。 12console.log(Object.getPrototypeOf(person1) == Person.prototype) // trueconsole.log(Object.getPrototypeOf(person1).name ) // &apos;Trump&apos; 第一行代码只是确定Object.getPrototypeOf() 返回的对象实际就是这个对象的原型。第二行代码取得原型对象中name 属性的值，也就是’Trump’。使用Object.getPrototypeOf() 可以方便地取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。 当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person1.sayName()的时候，会先后执行两次搜索。首先，解析器会问：“实例person1 有sayName 属性吗？”答：“没有。”然后，它继续搜索，再问：“person1 的原型有sayName 属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。这就是多个对象实例共享原型所保存的属性和方法的基本原理。 尽管可以通过对象实例访问保存在原型的值，但是不能通过对象实例重写原型中的值： 12345678910function Person () &#123;&#125;Person.prototype.name = &apos;Trump&apos;Person.prototype.age = 71const person1 = new Person()const person2 = new Person()person1.name = &apos;Hilary&apos;console.log(person1.name) // &apos;Hilary&apos; 来自实例console.log(person2.name) // &apos;Trump&apos; 来自原型 如果在实例添加一个属性，该属性与实例原型中的一个属性同名，那么在实例中创建的该属性就会屏蔽掉原型中的那个同名属性。但访问person1.name 时，因为在实例上就已经找到名为name的属性，所以直接就返回了实例上的name，而没有进一步搜索至原型。以同样方式搜索person2.name，因为实例上没有name属性，所以就搜索至原型的name 属性了。 在实例上添加的属性只会阻止我们访问原型的同名属性，但不会对原型上的属性有所修改。即使在实例上将这个属性设为null，也只是在实例上设置这个属性，而不会恢复其指向原型的链接。 123456789101112function Person () &#123;&#125;Person.prototype.name = &apos;Trump&apos;const person1 = new Person()const person2 = new Person()person1.name = &apos;Hilary&apos;console.log(person1.name) // &apos;Hilary&apos; 来自实例console.log(person2.name) // &apos;Trump&apos; 来自原型delete person1.nameconsole.log(person1.name) // &apos;Trump&apos; 来自原型 不过，使用delete操作符可以完全删除实例属性，从而可以正常重新访问原型属性。 使用hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法只在给定属性存在于对象实例中时，才返回true： 123456789function Person () &#123;&#125;Person.prototype.name = &apos;Trump&apos;const person1 = new Person()console.log(person1.hasOwnProperty(&apos;name&apos;)) // falseperson1.name = &apos;Clinton&apos;console.log(person1.name) // &apos;Clinton&apos; 来自实例console.log(person1.hasOwnProperty(&apos;name&apos;)) // true 原型与in 操作符有两种方式使用in 操作符，单独使用或在for-in 循环中使用。在单独使用时，in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中 123456789101112131415161718function Person () &#123;&#125;Person.prototype.name = &apos;Trump&apos;const person1 = new Person()const person2 = new Person()console.log(person1.hasOwnProperty(&apos;name&apos;)) // falseconsole.log(&apos;name&apos; in person1) // trueperson1.name = &apos;Clinton&apos;console.log(person1.name) // &apos;Clinton&apos; 来自实例console.log(person1.hasOwnProperty(&apos;name&apos;)) // trueconsole.log(&apos;name&apos; in person1) // truedelete person1.nameconsole.log(person1.name) // &apos;Trump&apos; 来自原型console.log(person1.hasOwnProperty(&apos;name&apos;)) // falseconsole.log(&apos;name&apos; in person1) // true 如果同时使用hasOwnProperty() 方法和in 操作符，可以确定该属性到底是存在于实例中还是存在于原型中： 123456789101112function hasPrototypeProperty (obj, name) &#123; return !object.hasOwnProperty(name) &amp;&amp; (name in obj)&#125;function Person () &#123;&#125;Person.prototype.name = &apos;Trump&apos;const person1 = new Person()console.log(hasPrototypeProperty(person1, &apos;name&apos;)) // trueperson1.name = &apos;Clinton&apos;console.log(hasPrototypeProperty(person1, &apos;name&apos;)) // false 在使用for-in 循环时，返回的是所有能够通过对象访问的，可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记的属性，如一些原生方法等）的实例属性也会在for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的。 1234567891011const o = &#123; toString: function () &#123; return &apos;My Object&apos; &#125;&#125;for (let prop in o) &#123; if (prop == &apos;toString&apos;) &#123; console.log(&apos;Found toString! &apos;) &#125;&#125; 对象o定义的toString() 方法屏蔽了原型中不可枚举的toString() 方法（原生方法）。因此toString变得可枚举，最后可以成功执行console.log() 。 要取得对象上所有可枚举的实例属性，可以用ES5 的Object.keys() 方法。这个方法接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组： 1234567891011121314151617function Person () &#123;&#125;Person.prototype.name = &apos;Trump&apos;Person.prototype.age = 71Person.prototype.job = &apos;President&apos;Person.prototype.sayName = function () &#123; console.log(this.name)&#125;const keys = Object.keys(Person.prototype)console.log(keys) // &apos;name, age, job, sayName&apos;const p1 = new Person()p1.name = &apos;Jiang&apos;p1.age = &apos;999&apos;const p1keys = Object.keys(p1)console.log(p1keys) // &apos;name, age&apos; 如果想要得到所有实例属性，无论是否可枚举，可以使用Object.getOwnPropertyNames() 方法。 1const keys = Object.getOwnPropertyName(Person.prototype) 总结： Object.keys(obj);返回obj的自身(不包含原型链上的)的所以可枚举属性的名字数组 for in循环则包含原型链 123for(name in obj)&#123; console.log(name) // 将把自身的属性名和原型链上的属性名挨个输出(只输出可枚举的)&#125; Object.getOwnPropertyNames(obj)，返回obj自身(不含原型链上的)的所有属性名数组，包括不可枚举的。 想要获得原型上的属性信息，使用Object.getPrototypeOf(obj)，先得到原型再操作还有”property” in obj检测属性是否存在，检测所有。包括原型链上的，包括不可枚举的。 参考：https://www.zhihu.com/question/34733819/http://www.cnblogs.com/wujie520303/p/4931384.html 原型语法前面老是要写一遍Person.prototype 真的有点麻烦，更普遍的写法其实是用包含所有属性和方法的字面量去重写整个原型对象： 123456789function Person () &#123;&#125;Person.prototype = &#123; name: &apos;Trump&apos;, age： 71， job: &apos;President&apos;, sayName: function () &#123; console.log(this.name) &#125;&#125; 上面的代码将Person.prototype 设置为等于一个以对象字面量形式创建的新对象，最终结果与前面老是敲Person.prototype 相同，但是！他的constructor 属性不再指向Person 了！因为每创建一个函数，就会同事创建它的prototype对象，这个prototype对象也会自动获得constructor 属性。而这里的语法，本质上完全重写了默认的prototype 对象，所以constructor 属性变成了新对象的constructor 属性，也就是指向了Object 构造函数，不再指向Person 函数。尽管instanceof 操作符还能返回正确的结果，但通过constructor 已经无法确定对象的类型了： 123456// 接上面const nigga = new Person()console.log(nigga instanceof Object) // trueconsole.log(nigga instanceof Person) // trueconsole.log(nigga.constructor == Person) // falseconsole.log(nigga.constructor == Object) // true 如果要确保constructor 属性一定要指向原来的函数，可以这样： 12345678910function Person () &#123;&#125;Person.prototype = &#123; constructor: Person, name: &apos;Trump&apos;, age： 71， job: &apos;President&apos;, sayName: function () &#123; console.log(this.name) &#125;&#125; 不过这样写的话会导致constructor 属性的[[Enumerable]]特性被设置为true，原生的constructor 属性是不可枚举的，想避免这个问题可以这样： 1234567891011121314function Person () &#123;&#125;Person.prototype = &#123; name: &apos;Trump&apos;, age： 71， job: &apos;President&apos;, sayName: function () &#123; console.log(this.name) &#125;&#125;Object.defineProperty(Person.prototype, &apos;constructor&apos;, &#123; enumerable: false, value: Person&#125;) 原型的动态性123456const person = new Person()Person.prototype.sayHi = function() &#123; alert(&apos;Hi&apos;)&#125;person.sayHi() // &apos;Hi&apos; 初看以上代码会觉得很奇怪，如果是在C或是C++中是不可能在创建对象后还能够在对象创建之后访问类新添加的属性方法。在js中，这个person.sayHi()不仅不会报错反而会正常执行弹出hi的窗口。在内存中，每个对象或是每个实例都通过一个__proto__ 的指针访问相应的property，这有点类似于C++里面的动态调用亦或是动态联编，通过指针来动态的访问内存的数据。 1234567891011const person = new Person()Person.prototype = &#123; constructor : Person, name : &apos;Trump&apos;, age : 71, sayName ： function() &#123; console.log(this.name) &#125;&#125;person.sayName() //error 此处出错的原因在于我们重写原型后任何原型与之前存在的对象实例之间的关系已经中断，而它们依然引用的是最初的原型，而最初的原型中不包含sayName（）以及其他重写的属性而是一个Person模型，自然要报错。 上面两段代码有一些说不清道不明的别扭，第一个与第二个的区别在于，第一个里的原型的指针指向是没有变化的，虽然原型增加了新的方法有发展变化，而第二个在完全重写后，先前创建的实例指向的原型没有改变，仍指向原来的原型，后面用对象字面量写法重写原型对象，那就已经不是原来的原型对象，指针指向的地址也必然不一样。有一点必须注意的就是constructor属性是为了确保通过该属性能访问到确切的值。前面提到过，重写默认原型对象造成的结果是constructor属性指向新的原型对象的constructor，即Object。 原型对象的问题原型模式的最大问题是其属性都被所有的实例所共享，这种共享对函数来说非常合适，但是对于一些包含引用类型值的属性来说就有问题了，比如数组： 123456789101112131415161718function Person () &#123;&#125;Person.prototype = &#123; name: &apos;Trump&apos;, age： 71， job: &apos;President&apos;, friends: [&apos;Putin&apos;, &apos;Abe&apos;] sayName: function () &#123; console.log(this.name) &#125;&#125;const person1 = new Person()const person2 = new Person()person1.friends.push(&apos;Kim&apos;)console.log(person1.friends) // &apos;Putin, Abe, Kim&apos;console.log(person2.friends) // &apos;Putin, Abe, Kim&apos;console.log(person1.friends === person2.friends) // true 修改person1 的friends 属性，但是person2 的却也受到了影响，因为他们引用的都是同一个来自原型上的数组。下面来看得怎么解决。 组合使用构造函数模式和原型模式为了避免以上提到的问题，在javascript 中我们最常用的是组合使用构造函数模式和原型模式。构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。那么每个实例都会有自己的一份实例属性的副本，但同时又共享着来自原型上的方法，节省了内存。并且还支持向构造函数传递参数： 12345678910111213141516171819202122function Person(name, age, job)&#123; this.name = name this.age = age this.job = job this.friends = [&apos;Putin&apos;, &apos;Abe&apos;]&#125;Person.prototype=&#123; contructor: Person, sayName: function()&#123; console.log(this.name) &#125;&#125;const person1 = new Person(&apos;Trump&apos;, 71, &apos;President&apos;)const person2 = new Person(&apos;Bieber&apos;, 23, &apos;wtf&apos;)person1.friends.push(&apos;Jiang&apos;)console.log(person1.friends) //Putin, Abe, Jiangconsole.log(person2.friends) //Putin, Abeconsole.log(person1.friends === person2.friedns) //falseconsole.log(person1.sayName === person2.sayName) //true 动态原型模式上面的代码中，构造函数和原型分别独立来定义看起来好像有点奇怪，于是就有了动态原型模式，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下）。可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型，本质上其实跟上面是差不多的，只不过多了个封装，可以在很多jQuery 插件中看到类似的写法。 12345678910111213141516function Person(name,age,job)&#123; // 属性 this.name=name this.age=age this.job=job this.friends=[&apos;Putin&apos;,&apos;Abe&apos;] // 方法 if (typeof this.sayName != &apos;function&apos;) &#123; Person.prototype.sayName = function () &#123; console.log(this.name) &#125; &#125;&#125;const friend = new Person(&apos;Trump&apos;, 71, &apos;President&apos;)friend.sayName() // &apos;Trump&apos; 这里只在sayName()方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用instanceof 操作符确定它的类型。 使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 参考：https://www.zhihu.com/question/41441895/answer/101616119 寄生构造函数模式寄生构造函数模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象，表面上看起来是挺像典型的构造函数，但是！实际上其实是工厂模式的一种变体，可以跟前面的工厂模式对比下就明白了。 12345678910111213function Person (name, age, job) &#123; const o = new Object() o.name = name o.age = age o.job = job o.sayName = function () &#123; console.log(this.name) &#125; return o&#125;const person1 = new Person(&apos;Trump&apos;, 71, &apos;President&apos;)person1.sayName() // Trump 这个模式可以在特殊情况下用来为对象创建构造函数，假如我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array 构造函数，可以使用这个模式： 123456789101112131415function SpecialArray () &#123; // 创建数组 const values = new Array() // 添加值 values.push.apply(value, arguments) // 添加方法 values.toPipedString = function () &#123; return this.join(&apos;|&apos;) &#125; // 返回数组 return values&#125;const colors = new SpecialArray(&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;)console.log(colors.toPipedString()) // &apos;red|blue|green&apos; 利用寄生构造函数模式,在不修改Array构造函数的情况下，通过为Array对象创建构造函数达到修改Array对象的目地。 分析上面的代码： const array = new Array() 创建了一个Array对象 return array 在经过一系列的修改之后返回修改之后的Array对象 const colors = new SpecialArray(“red”,”blue”,”black”) 创建了一个SpecialArray 对象,接收的确是修改之后的Array对象的实例值 所以return array 返回的对象是Array类型，而且colors接收了这个返回的对象，所以colors并不是SpecialArray构造函数的实例，而是Array的实例,下面的代码可以说明： 12alert(colors instanceof SpecialArray) // falsealert(colors instanceof Array) // true 由于存在上述问题，如果能使用其他的模式的情况下，建议不要使用这种模式。 稳妥构造函数模式所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this 的对象。稳妥对象最适合用在一些安全的环境中（这些环境会禁止使用new 和this ），或者防止数据被其他的应用改动。 1234567891011121314function Person(name, age) &#123; //创建要返回的对象 const o = new Object() //可以在这里定义私有变量和函数 //添加方法 o.sayName = function () &#123; console.log(name) &#125; //返回对象 return o&#125;const person = Person(&apos;Trump&apos;, 71)person.sayName() // 使用稳妥构造函数模式只能通过其构造函数内部的方法来获取里面的属性值 稳妥构造函数与寄生构造函数模式类似，也是跟工厂模式相似，但是也有两点区别： 稳妥模式不使用new操作符调用构造函数 新创建对象的实例方法不引用this 上面的代码定义了person 变量，里面保存的是一个稳妥对象，而除了吊用他的sayName() 方法外，没有别的方法可以访问其数据成员。即使有其他的代码会给这个对象添加方法和数据成员，但也不可能有别的方法访问到传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性。使得它非常适合在某些安全执行环境中。 继承Javascript 的实现继承主要是依靠原型链来实现的，那么什么是原型链？ 原型链 原型链是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 谨记：每个构造函数都有一个原型对象(.prototype)，原型对象都包含一个指向构造函数的指针(.constructor)，而实例都包含一个指向原型对象的内部指针(.proto)。 基本概念：假如我们让原型对象等于另一个类型的实例，那么原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，上述关系依然成立，层层递进构成了实例与原型的链条。 123456789101112131415161718function SuperType () &#123; this.property = true&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property&#125;function SubType () &#123; this.subproperty = false&#125;// 继承了 SuperTypeSubType.prototype = new SuperType()SubType.prototype.getSubValue = function () &#123; return this.subproperty&#125;const instance = new SubType()console.log(instance.getSuperValue()) // true 以上代码定义了两个类型：SuperType和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例，换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了，在确立了继承关系之后，我们给SubType.prototype添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如图所示： 可以看到在上面的代码中，没有使用SubType 默认的原型，而是换了一个新原型，就是SuperType 的实例。新原型不仅具有作为SuperType 的实例的全部属性和方法，而且内部还有一个指针，指向了SuperType 的原型。最终实际的结果是：instance 指向SubType 的原型，SubType 的原型又指向SuperType 的原型。getSuperValue() 方法仍然还在SuperType.prototype 中，但property 则位于SubType.prototype 中。这是因为property 是一个实例属性，而getSuperValue() 则是一个原型方法。既然SubType.prototype 现在是SuperType 的实例，那么property 当然位于实例中。此外，要注意instance.constructor 现在指向的是SuperType，这是因为原来的SubType.prototype 中的constructor 被重写了的缘故。 通过实现原型链，本质上扩展了原型搜索机制。通过原型链实现继承的情况下，搜索属性过程就是沿着原型链向上。上面的例子中，调用instance.getSuperValue()会经历三个搜索步骤：1)搜索实例；2)搜索SubType.prototype；3)搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。 传说中默认的原型不要忘了，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object 的实例，因此默认原型会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf() 等默认方法的根本原因。所以，上面例子展现的原型链还应该包括另外一个继承层次： 一句话，SubType继承了SuperType,而SuperType继承了Object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法。 确定原型和实例的关系通过instanceof 操作符可以测试实例与原型的关系。 123alert(instance instanceof Object) //truealert(instance instanceof SuperType) //truealert(instance instanceof SubType) //true 123alert(Object.prototype.isPrototypeOf(instance)) // truealert(SuperType.prototype.isPrototypeOf(instance)) //truealert(SubType.prototype.isPrototypeOf(instance)) //true 谨慎地定义方法子类型有时候需要重写超类型中的某个方法，或者添加超类型中不存在的某个方法。但给原型添加方法的代码一定要放在替换原型的语句之后： 1234567891011121314151617181920212223function SuperType () &#123; this.property = true&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property&#125;function SubType () &#123; this.subproperty = false&#125;// 继承了SuperTypeSubType.prototype = new SuperType()// 添加新方法SubType.prototype.getSubValue = function () &#123; return this.subproperty&#125;// 重写超类型中的方法SubType.prototype.getSuperValue = function () &#123; return false&#125;const instance = new SubType()console.log(instance.getSuperValue()) // false 后面注释的两个方法定义。第一个方法getSubValue() 被添加到了SubType 中。第二个方法getSuperValue() 是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当通过SubType 的实例调用getSuperValue() 时，调用的就是这个重新定义的方法；但通过SuperType 的实例调用getSuperValue() 时，还会继续调用原来的那个方法。这里要格外注意的是，必须在用SuperType 的实例替换原型之后，再定义这两个方法。 另外，记得记得不能使用对象字面量去创建原型方法。因为这样会重写原型链！ 123456789101112131415161718192021222324function SuperType() &#123; this.property = true&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property&#125;function SubType() &#123; this.subproperty = false&#125;//继承了SuperTypeSubType.prototype = new SuperType()//使用字面量添加新方法，会导致上一行代码无效SubType.prototype = &#123; getSubValue: function() &#123; return this.subproperty &#125;, someOtherMethod: function() &#123; return false &#125;&#125;const instance = new SubType()alert(instance.getSuperValue()) // error! 上面的代码展示了刚刚把SuperType的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想中的原型链已经被切断——SubType和SuperType之间已经没有关系了。 原型链的问题原型链的问题来自包含引用类型值的原型。前面提到过，包含引用类型值的原型属性会被所有实例共享，这也正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是原先的实例属性也就变成了现在的原型属性： 1234567891011121314function SuperType () &#123; this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]&#125;function SubType() &#123;&#125;// 继承SuperTypeSubType.prototype = new SuperType()const instance1 = new SubType()instance1.colors.push(&apos;black&apos;)console.log(instance1.colors) // &apos;red, blue, green, black&apos;const instance2 = new SubType()console.log(instance2.colors) // &apos;red, blue, green, black&apos; 原型链的第二个问题是在创建子类型的实例时，不能向超类型的构造函数中传递参数。没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。所以实践中一般很少单独使用原型链，都要用下面的继承方式去解决。 借用构造函数借用构造函数，即在子类型的构造函数的内部调用超类型的构造函数。因为函数只不过是在特定环境中执行的代码对象，因此通过使用apply() 和call() 方法可以在将来新创建的对象上执行构造函数： 123456789101112131415function SuperType () &#123; this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]&#125;function SubType() &#123; // 继承SuperType SuperType.call(this)&#125;const instance1 = new SubType()instance1.colors.push(&apos;black&apos;)console.log(instance1.colors) // &apos;red, blue, green, black&apos;const instance2 = new SubType()console.log(instance2.colors) // &apos;red, blue, green&apos; 上面代码中，通过使用call()方法（或apply()方法也可以），我们实际上是在将要新创建的SubType 实例的环境下调用了SuperType 构造函数。这样一来，就会在SubType()函数中定义的所有对象初始化代码。每个SubType 的实例就都将具有自己的colors 属性副本了。 传递参数借用构造函数另一个优点是可以在子类型构造函数中向超类型构造函数传递参数： 12345678910111213function SuperType(name) &#123; this.name = name&#125;function SubType() &#123; // 继承SuperType 同时传参 SuperType.call(this, &apos;Trump&apos;) this.age = 71&#125;const instance = new SubType()console.log(instance.name) // &apos;Trump&apos;console.log(instance.age) // 71 为了确保SuperType 构造函数不会重写子类型的属性，可以在调用超类型的构造函数后，再添加应该在子类型中定义的属性。 借用构造函数的问题借用构造函数无法避免构造函数模式存在的问题——方法不得不都在构造函数中定义，所以函数复用又无从谈起了。而且超类型的原型中定义的方法，对子类型也是不可见的，结果所有类型都只能使用构造函数模式，用例子说话： 12345678910111213141516171819202122function Parent0()&#123; this.name = &quot;parent0&quot; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]&#125;function Child0()&#123; Parent0.call( this ) // 或apply this.type = &quot;child0&quot;&#125;const instance1 = new Child0() console.log(instance1.name) // parent0console.log(instance1.colors) // (3) [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;]Parent0.prototype.sex = &quot;男&quot;Parent0.prototype.say = function() &#123; console.log(&quot;Oh, My God! &quot;)&#125;const instance2 = new Child0() console.log(instance2.sex) // undefinedinstance2.say() // Uncaught TypeError: (intermediate value).say is not a function 第6行，在子类（Child0）中执行父类（Parent0）的构造函数，通过这种调用，把父类构造函数的this指向为子类实例化对象引用，从而导致父类执行的时候父类里面的属性都会被挂载到子类的实例上去。 12console.log(instance1 instanceof Child0) // trueconsole.log(instance1 instanceof Parent0) // false 可以看到，instance1 虽然是子类的实例，但是却不是父类的实例，在创建子类实例的过程中，借用构造函数仅仅是将父类实例上属性和方法“附上”、“注入”进子类实例，子类实例并不是真正的父类实例，所以父类原型上的东西也没法继承的，因此并没有真正的实现继承（部分继承）。 组合式继承组合继承，是将原型链和借用构造函数结合在一起，汲取了两个方式的优点。基本思想是使用原型链实现对原型属性和方法的继承，然后再通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性： 123456789101112131415161718192021222324252627282930function SuperType (name) &#123; this.name = name this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType (name, age) &#123; // 继承属性 SuperType.call(this, name) this.age = age&#125;// 继承方法SubType.prototype = new SuperType()SubType.prototype.sayAge = function() &#123; console.log(this.age)&#125;const instance1 = newSubType(&apos;Trump&apos;, 71)instance.colors.push(&apos;black&apos;)console.log(instance1.colors) // &apos;red, blue, green, black&apos;instance1.sayName() // &apos;Trump&apos;instance1.sayAge() // 71const instance2 = newSubType(&apos;Kim&apos;, 33)console.log(instance1.colors) // &apos;red, blue, green&apos;instance1.sayName() // &apos;Kim&apos;instance1.sayAge() // 33 上面的代码，Supertype 构造函数定义了name 和colors 两个属性，SuperType 的原型定义了一个方法sayName()。SubType 构造函数在调用SuperType 构造函数时传入了name 参数，然后又定义了自己的属性age。然后再将SuperType 的实例赋值给SubType 的原型，然后又在该新原型上定义了方法sayAge()。这样，可以让不同的SubType 实例分别拥有自己的属性，又拥有相同的方法（来自SuperType 原型）。组合继承是javascript中最常用的继承模式，而且instanceof 和isPrototypeOf() 也能用于识别组合继承模式创建的对象。 要说缺点。父类的构造函数被执行了两次，第一次是SubType.prototype = new SuperType()，第二次是在实例化时，借用构造函数的时候，后面覆盖了前面的，这是没有必要的。 寄生组合式继承（组合式继承优化）12345678910111213141516171819202122232425262728293031function SuperType (name) &#123; this.name = name this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType (name, age) &#123; // 继承属性 SuperType.call(this, name) this.age = age&#125;// 继承方法的优化SubType.prototype = Object.create(SuperType.prototype)SubType.prototype.constructor = SubtypeSubType.prototype.sayAge = function() &#123; console.log(this.age)&#125;const instance1 = newSubType(&apos;Trump&apos;, 71)instance.colors.push(&apos;black&apos;)console.log(instance1.colors) // &apos;red, blue, green, black&apos;instance1.sayName() // &apos;Trump&apos;instance1.sayAge() // 71const instance2 = newSubType(&apos;Kim&apos;, 33)console.log(instance1.colors) // &apos;red, blue, green&apos;instance1.sayName() // &apos;Kim&apos;instance1.sayAge() // 33 这里的关键在于，我们把之前的SubType.prototype = new SuperType() 改成了 12SubType.prototype = Object.create(SuperType.prototype)SubType.prototype.constructor = SubType 因为这样改写SubType.prototype 跟用对象字面量改写一样会导致原型丢失，所以需要对constructor 做重新指定。 Object.create是一种创建对象的方式，它会创建一个中间对象。 12const p = &#123;name: &quot;p&quot;&#125;const obj = Object.create(p) // Object.create(&#123; name: &quot;p&quot; &#125;) 通过这种方式创建对象，新创建的对象obj的原型就是p，同时obj也拥有了属性name，这个新创建的中间对象的原型对象就是它的参数。 寄生组合式继承只调用了一次SuperType 的构造函数，并且因此避免了在SubType.prototype 上面创建不必要的多余属性。同时原型链还能保持不变，所以寄生组合式继承可以说是最理想的继承方式了。 原型式继承原型式继承是指借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型： 1234567891011121314151617181920fuction object (o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;const person1 = &#123; name: &apos;Trump&apos;, friends: [&apos;Putin&apos;, &apos;Abe&apos;]&#125;const person2 = object(person1)person2.name = &apos;Kim&apos;person2.friends.push(&apos;Jiang&apos;)console.log(person1.friends) // &apos;Putin&apos;, &apos;Abe&apos;, &apos;Jiang&apos;const person3 = object(person1)person3.name = &apos;Macron&apos;person3.friends.push(&apos;Merkel&apos;)console.log(person1.friends) // &apos;Putin, Abe, Jiang, Merkel&apos; 原型式继承的核心是，必须以一个对象作为新对象的基础，以上的代码，将person1 这个对象传进object() 函数中，在创建person2和person3的过程中，都是person1 将作为对象基础，然后再被返回出来。因为新对象是以person1 作为原型，所以他们原型上就包含了person1 的基本类型值属性(name)和引用类型值属性(friends)。person1.friends 也将被person2 和person3 共有，可以看到在person2 和person3 对friends 做的修改在person1 也体现出来了。 寄生式继承寄生式继承与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象： 12345678// 接上面的object()函数function createAnother (original) &#123; const clone = object(original) clone.sayHi = function () &#123; console.log(&apos;hi&apos;) &#125; return clone&#125; 上面的代码，createAnother() 函数接受一个参数，也就是将要作为新对象基础的对象。然后把这个对象传递给object() 函数，将返回的结果赋给clone。再为clone 对象添加新方法sayHi()，最后返回clone 对象。 12345678// 接上面const person = &#123; name: &apos;Trump&apos;, friends: [&apos;Putin&apos;, &apos;Abe&apos;]&#125;const anotherPerson = createAnother(person)anotherPerson.sayHi() 在这里，新对象anotherPerson 具有person 的所有属性和方法，而且还有自己的sayHi() 方法。 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式，上述代码中使用的object() 函数不是必须的，任何能够返回新对象的函数都适用此模式。缺点就是使用寄生式继承为对象添加的函数，还是做不到函数复用。 ES6的继承Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 123456789101112class Parent &#123;&#125;class Child1 extends Parent &#123; constructor(x, y, colors) &#123; super(x, y); // 调用父类的constructor(x, y) this.colors = colors; &#125; toString() &#123; return this.colors + &apos; &apos; + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。如果子类没有定义constructor方法，这个方法会被默认添加，不管有没有显式定义，任何一个子类都有constructor方法。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 参考： https://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;mid=2676491918&amp;idx=1&amp;sn=2a30b02356595e974537c78b2a82f8eb http://www.jianshu.com/p/3c2333034429]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>基础概念</tag>
        <tag>原型</tag>
        <tag>继承</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域与闭包详解]]></title>
    <url>%2Fposts%2Fjavascript%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[函数作用域执行环境(execution context)是js中最为重要的一个概念，执行环境定义了变量或者函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围的一个执行环境，在web浏览器中，全局执行函数被认为是window对象，因此所有全局变量和函数都作为window对象的属性和方法创建的。某个执行环境中所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。全局执行环境直到应用程序退出也随之销毁(关闭网页和浏览器的时候)。(引自《javascript高级编程第四章73页》)。 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在一开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境；全局执行环境始终是作用域链中的最后一个对象。 123456function galaxy () &#123; function solar () &#123; var earth = &apos;i am blue star&apos; &#125;&#125; 可以看到earth变量是在solar执行环境中，而solar又是在galaxy的执行环境中，earth的作用域链就是从solar-&gt;galaxy-&gt;window 全局作用域12345678var hello = &apos;Hello Trump!&apos;function sayHello () &#123; console.log(hello)&#125;console.log(hello) // &apos;Hello Trump!&apos;sayHello() // &apos;Hello Trump!&apos; 一旦声明了一个全局变量，那么在任何地方都可以使用它，包括函数内部。 局部作用域1234567function sayHello () &#123; var hello = &apos;Hello Trump!&apos; console.log(hello)&#125;sayHello() // &apos;Hello Trump!&apos;console.log(hello) // Error, hello is not defined 在这里hello是在sayHello函数中的局部变量，只存在于该局部作用域内，因此在函数外无法访问。 总结：在ES6之前，js的作用域只有两种： 1、 全局作用域； 2、 函数作用域。 作用域分为局部作用域和全局作用域。有如下几种情况可归纳为全局作用域： ①最外层函数和在最外层函数外面定义的变量拥有全局作用域。 ②所有末定义直接赋值的变量自动声明为拥有全局作用域。 ③所有window对象的属性拥有全局作用域。而局部作用域：是函数内部的作用域，一般只在固定的代码片段内可访问到，有时候也成为函数作用域。这里引申一下变量的搜索机制：先搜索局部变量，如果没找到，往上一层查找，直到搜索全部变量，如果都没找到，返回undefined。 变量提升/函数提升变量提升/函数提升,顾名思义,就是把定义在后面的变量或者函数,提升到前面来使用。1234567891011// 此段代码实际等同下段sayHello()function sayHello () &#123; console.log(&apos;Hello Trump!&apos;)&#125;// 此段代码实际等同上段function sayHello () &#123; console.log(&apos;Hello Trump!&apos;)&#125;sayHello() 要记住的是，只有函数声明才存在函数提升，如果是像下面那样使用函数表达式来定义，函数就不会被提升到变量作用域的顶部。 1234sayHello() // Error, sayHello is not definedvar sayHello = function () &#123; console.log(aFunction)&#125; 再来看下变量提升。12345678910console.log(global); // undefinedvar global = &apos;global&apos;;console.log(global); // global function fn () &#123; console.log(a); // undefined var a = &apos;aaa&apos;; console.log(a); // aaa&#125;fn(); 由于js的变量提升，实际上上面的代码是按照以下来执行的 123456789101112var global; // 变量提升，全局作用域范围内，此时只是声明，并没有赋值console.log(global); // undefinedglobal = &apos;global&apos;; // 此时才赋值console.log(global); // 打印出global function fn () &#123; var a; // 变量提升，函数作用域范围内 console.log(a); a = &apos;aaa&apos;; console.log(a);&#125;fn(); 块级作用域前面说到在ES6之前，js的作用域只有全局作用域和函数局部作用域两种东西，而缺少了块级作用域。啥是块级作用域呢？花括号封闭的代码块就是块级作用域。1234if(true) &#123; var color = &quot;blue&quot;;&#125;alert(color); // blue 这里是在一个if语句中定义了变量color，如果是在C、C++或Java中，color 会在if 语句之行完毕后被销毁，后面将会是alert不出color的。但在javascript中，if语句中的变量声明会将变量添加到当前的执行环境(在这个例子中是全局环境)中。 ES6的块级作用域let但是！在ES6中，新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面再来看下经典的案例！下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是用var命令声明的，还记得前面提过的，因为javascript没有块级作用域，变量声明会将变量添加到当前的执行环境！在这里var声明的变量就变成了一个全局变量，跟a平起平坐，在全局范围内都有效了！ 然鹅很不幸的是，全局又只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，根据作用域链的原则，因为在里面的这个匿名函数内也没有一个叫i的局部变量，所以里面的i只好向上一层，最后指向就是前面那个全局的i了。也就是说，所有数组a的成员里面的i，指向的都是同一个i，到最后循环结束时，i的值已经是10，所以运行时输出的都是指向最后一轮的i的值，也就是10。所以结论就是都是var惹的祸啊！ 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，跟上面最大的不同就是，这里每一轮的i可以看成是一个局部变量，而没有像上面那样坑爹变成一个全局变量！里面的这个匿名函数每一轮都会指向当前这一轮的i的值。每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升 var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // &quot;undefined&quot; 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 为什么需要块级作用域？ ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，也就是上面介绍let时的例子，用来计数的循环变量泄露为全局变量。 1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 const除了let以外，新增的const声明一个只读的常量。一旦声明，常量的值就不能改变。const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = &quot;Hello!&quot;;let age = 25;// 以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30; 本质 重点来了！const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push(&apos;Hello&apos;); // 可执行a.length = 0; // 可执行a = [&apos;Dave&apos;]; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 总结：可以看到，let和const是对var的一个更完善的补充，那么问题来了，什么时候用let什么时候用const什么时候用var呢? let、const在任何情况下都优于var！所以没啥事就不要用var了！ const用于声明常量，一般用于不可以被重新赋值的变量。 而let是定义普通的变量。 大部分情况下const的出场率比let高很多，所以一般建议默认使用const，除非一定要改变变量的值，再使用let。 说白了，赋值之后不会再做修改了就用const，如果后边还会修改就用let，总之不建议使用var。 参考http://www.zcfy.cc/article/javascript-scope-and-closures-css-tricks-4107.html?t=new http://www.cnblogs.com/giggle/archive/2016/06/13/5572006.html https://segmentfault.com/q/1010000000375714 https://www.zhihu.com/question/22786933 http://www.cnblogs.com/aaronjs/articles/2167431.html http://blog.csdn.net/tyro_java/article/details/51137776 http://www.cnblogs.com/zhangxiaos/p/6215420.html http://es6.ruanyifeng.com/#docs/let http://www.cnblogs.com/ziyunfei/p/6038213.html https://www.zhihu.com/question/51820539 https://segmentfault.com/q/1010000005079405 闭包什么是闭包 简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。为什么需要闭包呢？ 局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。 占用更多内存 不容易被释放 何时使用？ 既想反复使用，又想避免全局污染。 在一个函数内新建另一个函数时，就相当于创建了一个闭包。内层函数就是闭包。通常情况下，为了能够使得外部函数的内部变量可以访问，一般都会返回这个闭包。 12345678910function outerFunc () &#123; const outer = &apos;I see the outer variable.&apos; function innerFunc () &#123; console.log(outer) &#125; return innerFunc&#125;outerFunc()() // I see the outer variable. 因为内部函数是返回值，因此你可以简化函数声明的部分： 123456789function outerFunc () &#123; const outer = `I see the outer variable!` return function innerFunc() &#123; console.log(outer) &#125;&#125;outerFunc()() // I see the outer variable! 再来看看前面的for循环例子 1234567891011121314151617181920// 闭包改造前var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10// 闭包改造后var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = (function (i)&#123; return function ()&#123; console.log(i) &#125; &#125;)(i)&#125;a[6](); // 6 修改之后的版本中，arr数组每次添加新项是都会使得自执行函数执行，并将i作为实参传入了自执行函数，关键点是 function(i){…}(i)中第一个i是函数的形参，是私有变量，与外面的i没有关系，被私有作用域保护起来了，第二个i才是函数中外面的i（也就是说第一个i只是一个迷惑人的量，你改成k也是一样的结果，只不过是把i赋给k而已），这样一来，每次触发自执行函数时，都相当于将当前循环的变量i存储了下来。当arr中每一项执行时，调用了自执行函数返回的一个新地址的函数，也就是被return出来的里层函数，这个新地址的函数会去上级作用域去寻找i，上级作用域是形成这个新地址时的自执行函数，上级作用域中的i（或者说是上级作用域中那个形参）就是他要找的i。这种保护私有变量的机制就是闭包。 关键点在以下 JavaScript传参是传的复制值不是引用值，也就是我执行的时候 i 是啥我就alert啥 第一段代码中并不是传参，只是在函数内部引用了i变量。 第二段代码是把 i 作为参数传到了函数里，函数内部会复制传进来的 i 的值（参见第一条），然后再存到数组里。 因此，第一段代码中在执行函数的时候， i 已经在for循环中变为3，alert出来就是3，而第二段代码中函数数组中的函数因为参数都是复制的不同的i，所以每个包含的参数都是不同的，因此也就能够输出0,1,2,3。 参考https://www.zhihu.com/question/33468703]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 高级手册读书笔记01:数据类型]]></title>
    <url>%2Fposts%2Fjavascript%2FJavascript-%E9%AB%98%E7%BA%A7%E6%89%8B%E5%86%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B001-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[数据类型javascript中有五种简单数据类型（基本数据类型）：Undefined, Null, String, Number, Boolean。一种复杂数据类型（引用数据类型）：Object。 javascript中的变量是松散类型（即弱类型）的，可以用来保存任何类型的数据。 可以用typeof 操作符去检测给定变量的数据类型，可能的返回值： ‘undefined’ — 这个值未定义； ‘boolean’ — 这个值是布尔值； ‘string’ — 这个值是字符串； ‘number’ — 这个值是数值； ‘object’ — 这个值是对象或null； ‘function’ — 这个值是函数。 typeof 有不少的坑，比如： 1typeof null // &quot;object&quot; 因为特殊值null会被认为是一个空的对象引用，因此会得到这样的结果。所以严格来说typeof只能笼统地检测出数据类型，大多数情况下不建议使用，后面继续说更好的方法 Undefined 类型Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个值就是undefined。 12var messageconsole.log(typeof message) // &apos;undefined&apos; Null 类型Null类型和Undefined一样，也是只有一个值，即特殊的null。null值表示的是一个空的对象指针，这也就是typeof null会得到”object”的原因。 12var car = nullconsole.log(typeof car) // &apos;null&apos; 所以可以理解为Null是针对对象版的Undefined，要是定义了一个新的变量是准备拿来保存对象的，那么最好将其初始化为null而不是其他值，这样比较直观。另外要说一下，如果做比较: 12console.log(null == undefined) // trueconsole.log(null === undefined) // false 这也算是一个小坑，怪不得eslint要求无论什么时候都用”===”，因为”==”会帮我们类型转换，有时候需要准确结果的话，不见得是好事。 Boolean 类型Boolean类型是JavaScript中的一种原始类型，它只有两种值：true和false。 使用Boolean(value)方法可以强制转换任意值为boolean类型。 12345678alert(Boolean(&apos;&apos;)); //outpt false alert(Boolean(&apos;hello&apos;)); //output true alert(Boolean(100)); //output true alert(Boolean(0)); //output falsealert(Boolean(NaN)); //output falsealert(Boolean(null)); //output false alert(Boolean(undefined)); //output false alert(Boolean(new Object())); //output true 可以看出，当被转换的值为空字符串、数字0和NaN、null或者undefined时，转换为false，其它情况转换为true。所以当我们写if判断的时候需要注意这些特殊的情况，尤其是使用目前比较流行的“对象探测法”书写JS时。 1234567var student = new Object(); if (student.name) &#123; alert(student.name); &#125; else &#123; student.name = &apos;Tom&apos;; alert(student.name); &#125; if (student.name)这句用来探测student对象中存不存在name属性，如果存在则弹出；否则把name赋值为’Tom’，再弹出。这边需要注意的是如果name值已经存在，并且值为空字符串或者0时，结果可能与你预期的不同。 参考：http://blog.csdn.net/gudanyehai/article/details/6089255 Number 类型关于Number类型先占个坑，粗略要说下的是要记住八进制这个坑，还有浮点数大坑。。 NaNNaN(Not a Number)是Number类型的一个特殊值，这个数值表示一个本来要返回数值的操作数未返回数值的情况。比如，任何数除以0会返回NaN，另外，任何涉及NaN的操作，例如（NaN/10）都会返回NaN，NaN与任何值都不相等，包括NaN自身，这意味着（NaN == NaN）将返回 false。 针对这个如此特殊的值，规范中有了isNaN() 这个函数，用于检查其参数是否是非数字值。 12345alert(isNaN(NaN)) // truealert(isNaN(10)) // false （10是一个数值）alert(isNaN(&apos;10&apos;)) // false （可以被转换成数值10）alert(isNaN(&apos;blue&apos;)) // true （不能被转换成数值）alert(isNaN(true)) // false （可以被转换成数值1） 数值转换再次占个坑，有三个函数可以把非数值转换为数值，分别是：Number()、parseInt()和parseFloat()。第一个函数，Number()可以用于任何数据类型，而另外两个函数则专门用于把字符串转换成数值。 String 类型Object 类型前面提及的都是基本数据类型，Object数据类型是复杂数据类型。 类型判断typeof 和 instanceof在javascript中，typeof 和 instanceof 是用来判断数据类型比较通用的两个方法，这篇文章的目的是通过对这两个方法介绍来分析其存在的不足并提出优化方案。 typeoftypeof 返回一个表达式的数据类型的字符串，返回结果为javascript中的基本数据类型，包括：number、boolean、string、object、undefined、function等6种数据类型。 12345678typeof 100; //numbertypeof (1==1); //booleantypeof &apos;onepixel&apos;; //stringtypeof &#123;&#125; ; //objecttypeof onepixel; // undefinedtypeof parseInt; // functiontypeof [];//objecttypeof new Date(); //object 可以看出，typeof 可以准确的判断除object以外的基础数据类型，但不能区分object类型的具体类型，比如 Array 、Date 以及自定义类。 instanceofinstanceof 本意是用来判断 A 是否为 B 的实例对象，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：instanceof检测的是原型，那它是怎么检测的呢，我们用一段伪代码来模拟其内部执行过程： 123456789instanceof (A,B) = &#123;var L = A.__proto__;var R = B.prototype;if(L === R) &#123;//A的内部属性__proto__指向B的原型对象return true;&#125;return false;&#125; 从上述过程可以看出，当A的proto 指向B的prototype时，就认为A就是B的实例对象，我们再来看几个例子： 12345678[] instanceof Array; //true&#123;&#125; instanceof Object;//truenew Date() instanceof Date;//truefunction Person()&#123;&#125;;new Person() instanceof Person;[] instanceof Object; //truenew Date() instanceof Object;//trunew Person instanceof Object;//true 从上面的例子中，我们发现虽然instanceof能够正确判断[] 是Array的实例对象，但不能辨别 [] 不是Object的实例对象，为什么呢，这还需要从javascript的原型链说起，我们首先来分析一下[]、Array、Object 三者之间的关系，从instanceof判断能够得出：[].proto -&gt;Array.prototype， 而Array.prototype.proto指向了Object.prototype，Object.prototype.proto 指向了null,标志着原型链的结束。（ps:关于JS原型链请阅读：浅谈javascript原型和原型链） 因此，[]、Array、Object就形成了一条原型链： 从原型链可以看出，[]的proto最终指向了Object.prototype，类似的new Date()、new Person() 也会形成这样一条原型链，因此，我们用 instanceof 也不能完全精确的判断object类的具体数据类型。 参考：http://www.jb51.net/article/77948.htm Object.prototype.toString()在 JavaScript 里使用 typeof 来判断数据类型，只能区分基本类型，即 “number”，”string”，”undefined”，”boolean”，”object” 五种。 对于数组、函数、对象来说，其关系错综复杂，使用 typeof 都会统一返回 “object” 字符串。 要想区别对象、数组、函数单纯使用 typeof 是不行的，JavaScript中,通过Object.prototype.toString方法，判断某个对象值属于哪种内置类型。 1.判断基本类型： 12345Object.prototype.toString.call(null);//”[object Null]”Object.prototype.toString.call(undefined);//”[object Undefined]”Object.prototype.toString.call(“abc”);//”[object String]”Object.prototype.toString.call(123);//”[object Number]”Object.prototype.toString.call(true);//”[object Boolean]” 2.判断原生引用类型：函数类型 12Function fn()&#123;console.log(“test”);&#125;Object.prototype.toString.call(fn);//”[object Function]” 日期类型 12var date = new Date();Object.prototype.toString.call(date);//”[object Date]” 数组类型 12var arr = [1,2,3];Object.prototype.toString.call(arr);//”[object Array]” 正则表达式 12var reg = /[hbc]at/gi;Object.prototype.toString.call(arr);//”[object Array]” 自定义类型 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person(&quot;Rose&quot;, 18);Object.prototype.toString.call(person); //”[object Object]” 但是要注意的一点是，如果是自定义类型，则是还是需要用instanceof去判断很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示： 1console.log(person instanceof Person);//输出结果为true 参考：http://blog.csdn.net/icanlove/article/details/43702879 http://www.cnblogs.com/youhong/p/6209054.html http://www.cnblogs.com/ziyunfei/archive/2012/11/05/2754156.html http://www.cnblogs.com/wyaocn/p/5796142.html https://juejin.im/post/59b5540c5188257e8769e95d#comment]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>基础概念</tag>
        <tag>Javascript高级手册读书笔记</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的this，箭头函数中的this]]></title>
    <url>%2Fposts%2Fjavascript%2Fjavascript%E4%B8%AD%E7%9A%84this%EF%BC%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this.html</url>
    <content type="text"><![CDATA[在平常写javascript代码的时候，很多时候我们都需要用到this，不过在根据不同的场景下，this的指向却会有不同的结果。 1234567891011var a = 1;var obj = &#123; a: 2&#125;;function fun() &#123; var a = 3; let f = () =&gt; console.log(this.a); f();&#125;;fun();//1fun.call(obj);//2 如上，fun直接调用，fun的上下文中的this值为window，注意，这个地方有点绕。fun的上下文就是此箭头函数所在的上下文，因此此时f的this为fun的this也就是window。当fun.call(obj)再次调用的时候，新的上下文创建，fun此时的this为obj，也就是箭头函数的this值。 这也就是常说的箭头函数没有自己的this，箭头函数的this实际为其外层函数作用域中的this，可以看到作为箭头函数的f的，他的外层函数是fun，而此时fun作为全局函数调用，那么fun的this就是window，所以f里的this就指向了window了。 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，也就是说箭头函数的this在词法层面就完成了绑定。apply，call方法只是传入参数，却改不了this。 下面再来看下另外一个比较全面的例子。 123456789101112131415161718192021222324252627282930313233var name = &apos;window&apos;var person1 = &#123; name: &apos;person1&apos;, show1: function () &#123; console.log(this.name) &#125;, show2: () =&gt; console.log(this.name), show3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, show4: function () &#123; return () =&gt; console.log(this.name) &#125;&#125;var person2 = &#123; name: &apos;person2&apos; &#125;person1.show1() // person1person1.show1.call(person2) // person2person1.show2() // windowperson1.show2.call(person2) // windowperson1.show3()() // windowperson1.show3().call(person2) // person2person1.show3.call(person2)() // windowperson1.show4()() // person1person1.show4().call(person2) // person1person1.show4.call(person2)() // person2 在一般函数的情况下，this总是指向调用该函数的对象。person1.show1()很好理解，因为是person1对象调用的，所以this也就指向了person1对象，所以结果是person1。而person1.show1.call(person2) 则通过call方法将this指向了person2。 在箭头函数的情况下，person1.show2()的结果却是window，这是因为箭头函数的this指向外层函数作用域中的this，外层函数作用域中的this，实际上这时候并没有外层函数了，外层就是全局环境了，没有外层函数所以指向了window。 person1.show3是一个高阶函数，它返回了一个函数，分步走的话，应该是这样：123var func = person3.show()func() 从而导致最终调用函数的执行环境是window，但并不是window对象调用了它。所以说，this总是指向调用该函数的对象，这句话还得补充一句：在全局函数中，this等于window。 person1.show3().call(person2) 与 person1.show3.call(person2)() 也好理解了。前者是通过person2调用了最终的打印方法。后者是先通过person2调用了person1的高阶函数，然后再在全局环境中执行了该打印方法。 person1.show4()()，person1.show4().call(person2)都是打印person1。这好像又印证了那句：箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。因为即使我用过person2去调用这个箭头函数，它指向的还是person1。 然而person1.show4.call(person2)()的结果又是person2。this值又发生改变，看来上述那句描述又走不通了。一步步来分析，先通过person2执行了show4方法，此时show4第一层函数的this指向的是person2。所以箭头函数输出了person2的name。也就是说，箭头函数的this指向的是谁调用箭头函数的外层function，箭头函数的this就是指向该对象，如果箭头函数没有外层函数，则指向window。这样去理解show2方法，也解释的通。 参考：https://juejin.im/post/59748cbb6fb9a06bb21ae36dhttps://juejin.im/post/59aa71d56fb9a0248d24fae3]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS动画中的transform，transition以及animation的区别小结]]></title>
    <url>%2Fposts%2Fcss%2FCSS%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84transform%EF%BC%8Ctransition%E4%BB%A5%E5%8F%8Aanimation%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93.html</url>
    <content type="text"><![CDATA[在css学习中，尤其是动画部分，相信很多人都会接触过transform，transition以及animation属性，如果望文生义从字面上这些词翻译成中文好像都差不多，其实他们三者分别还是很大的。 transform先来看跟变形金刚transformer很像的transform， 首先要注意的是transform属性是静态属性！静态属性！静态属性！只要写进style里就会直接显示生效，不会出现动画过程。通过使用transform属性，能够对元素进行移动（translate）、缩放（scale）、旋转（rotate）、翻转（skew）。对于这些就不展开说，有兴趣的可以自行实践下就明白了。 12345678div&#123;transform: translate(50px,100px) rotate(30deg);-ms-transform: translate(50px,100px) rotate(30deg); /* IE 9 */-webkit-transform: translate(50px,100px) rotate(30deg); /* Safari and Chrome */-o-transform: translate(50px,100px) rotate(30deg); /* Opera */-moz-transform: translate(50px,100px) rotate(30deg); /* Firefox */&#125; transition不同于静态的transform，被称为过渡的transition是一个简单的动画属性，可以看作是是animation的简化版本，通常拿来配合事件触发使用，简单易用。他的语法是transition: property duration timing-function delay;单纯的代码不会触发过渡操作，需要通过用户的行为（如点击，悬浮等）触发，常见的触发的方式有： :hover :focus :checked 媒体查询触发 javascript触发 1234567891011121314div&#123;width:100px;height:100px;background:yellow;transition:width 2s ease-in-out 1.5s;-moz-transition:width 2s ease-in-out 1.5s; /* Firefox 4 */-webkit-transition:width 2s ease-in-out 1.5s; /* Safari and Chrome */-o-transition:width 2s ease-in-out 1.5s; /* Opera */&#125;div:hover&#123;width:300px;&#125; transition的属性 属性 描述 transition-property 执行过渡的css属性 transition-duration 执行过渡的持续时间 transition-timing-function 执行过渡的运动速率曲线 transition-delay 执行过渡的延迟时间 顺带一提transition-property的注意事项，他的可取值如下 none ：没有属性会获得过渡效果。 all ：所有属性都将获得过渡效果。 property ：定义应用过渡效果的 CSS 属性名称列表，以逗号分隔。 不是所有属性都能过渡，只有属性具有一个中间点值才具备过渡效果。完整列表，见这里。 transition的优点在于简单易用，但是它有几个很大的局限。 （1）transition需要事件触发，所以没法在网页加载时自动发生。 （2）transition是一次性的，不能重复发生，除非一再触发。 （3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 （4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。CSS Animation就是为了解决这些问题而提出的。 animation最后来说说最强的animation，animation与keyframes属性搭配使用，有类似flash的概念，animation实现动画效果主要由两部分组成： （1）通过类似Flash动画中的帧来声明一个动画 （2）在animation属性中调用关键帧声明的动画。 关键帧 keyframe 实现自定义动画，通过对关键帧的设定来实现，也就是规定从起始点（0%）到终点（100%）之间的具体节点上的动画样式。就好比一个人起床，睁开眼睛（0%），站起来（10%），穿上衣（40%），穿裤子（80%），整理面容（100%），这样子把每个节点串起来便是动画了。上面提到的transition局限性在于只有两个状态，其实就是相当于只能定义0%和100%。而animation能够自定义任意时间段节点的动画动作。 当在 @keyframes中创建动画时，需要将它捆绑到某个选择器，否则不会产生动画效果。 通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称(animation-name) 规定动画的时长(animation-duration) animation属性类似于transition，都是随着时间改变元素的属性值，其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果。 以下实例为把 “myfirst” 动画捆绑到 div 元素，时长：4 秒，infinite 表示运动次数为无限次，alternate 表示下一周期将逆向地播放。 1234567891011121314151617div&#123;width:100px;height:100px;background:red;animation:myfirst 4s infinite alternate;-moz-animation:myfirst 4s infinite alternate;/* Firefox */-webkit-animation:myfirst 4s infinite alternate; /* Safari and Chrome */-o-animation:myfirst 4s infinite alternate; /* Opera */&#125;@keyframes myfirst&#123;0% &#123;background:red;&#125;50%&#123;background:blue; transform: translate(20px,-20px)&#125;75%&#123;background:green;transform: translate(40px,0px) scale(1.5)&#125;100% &#123;background:yellow;transform: rotate(-45deg)&#125;&#125; 下面的表格列出了 @keyframes 规则和所有动画属性： 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性 animation-name 规定 @keyframes 动画的名称 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的运动速率曲线 animation-delay 规定动画何时开始，默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 animation-fill-mode 规定对象动画时间之外的状态。 参考资料：http://www.w3school.com.cn/css3/css3_animation.asphttp://www.cnblogs.com/aimyfly/p/3195898.htmlhttp://blog.csdn.net/XIAOZHUXMEN/article/details/52003135]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法测试1]]></title>
    <url>%2Fposts%2Fmarkdown%2F%E6%B5%8B%E8%AF%951.html</url>
    <content type="text"><![CDATA[通过在行首插入 1 到 6 个 # (如#大)，来定义对应的 1 到 6 阶 标题： 大大大在 Markdown 中段落由一行或者多行文本组成，相邻的两行文字会被视为同一段落，如果存在空行则被视为不同段落( Markdown 对空行的定义是看起来是空行就是空行，即使空行中存在 空格 TAB 回车 等不可见字符，同样会被视为空行 )。 第一行 两行之间存在空行，视为不同段落。 链接的语法为[链接名称]然后紧跟（链接） 豆瓣 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://www.douban.com 图片的语法为![图片名称]然后紧跟（图片链接） 倾斜粗体 删除线 这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字 项目 项目 项目 子项目 子项目 项目 * 项目 项目 项目 子项目 子项目 项目 * 列表 属性 描述 苹果 红色 香蕉 黄色 葡萄 紫色 *Hi* 一句话行内代码一句话。 多行代码使用 3 个反引号来标记(反引号一般位于键盘左上角，要用英文) ，在第一个 ｀｀｀ 后面可以跟语言类型，没有语言类型可以省略不写: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export default &#123; [type.ADDEVENT](states, obj)&#123; states.count++; obj.items.id = states.count; states.event.unshift(obj.items); func.local.set(states); &#125;, [type.EVENTDONE](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 2; states.event[i].time = func.getDate(); var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.EVENTTODO](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 1; var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.EVENTCANCEL](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 3; var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.CLEAREVENT](states)&#123; states.event = []; func.local.clear(); &#125;, [type.DELEVENT](states, info)&#123; if (states.event[info.index].id === info.id) &#123; states.event.splice(info.index, 1); &#125; else &#123; states.event.filter(function (d, i) &#123; if (d.id == info.id) &#123; states.event.splice(i, 1); &#125; &#125;) &#125; func.local.set(states); &#125;, [type.EDITEVENT](states, info)&#123; if (states.event[info.index].id === info.id) &#123; states.event[info.index].content = info.content; &#125; else &#123; states.event.filter(function (d) &#123; if (d.id == info.id) &#123; d.content = info.content; &#125; &#125;) &#125; func.local.set(states); &#125;&#125; 1$ hexo new "My New Post"]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>