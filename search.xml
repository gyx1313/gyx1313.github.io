<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[CSS动画中的transform，transition以及animation的区别小结]]></title>
      <url>%2Fgyx1313-blog%2Fcss%2F2017-06-13-CSS%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84transform%EF%BC%8Ctransition%E4%BB%A5%E5%8F%8Aanimation%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[在css学习中，尤其是动画部分，相信很多人都会接触过transform，transition以及animation属性，如果望文生义从字面上这些词翻译成中文好像都差不多，其实他们三者分别还是很大的。 transform先来看跟变形金刚transformer很像的transform， 首先要注意的是transform属性是静态属性！静态属性！静态属性！只要写进style里就会直接显示生效，不会出现动画过程。通过使用transform属性，能够对元素进行移动（translate）、缩放（scale）、旋转（rotate）、翻转（skew）。对于这些就不展开说，有兴趣的可以自行实践下就明白了。 12345678div&#123;transform: translate(50px,100px) rotate(30deg);-ms-transform: translate(50px,100px) rotate(30deg); /* IE 9 */-webkit-transform: translate(50px,100px) rotate(30deg); /* Safari and Chrome */-o-transform: translate(50px,100px) rotate(30deg); /* Opera */-moz-transform: translate(50px,100px) rotate(30deg); /* Firefox */&#125; transition不同于静态的transform，被称为过渡的transition是一个简单的动画属性，可以看作是是animation的简化版本，通常拿来配合事件触发使用，简单易用。他的语法是transition: property duration timing-function delay;单纯的代码不会触发过渡操作，需要通过用户的行为（如点击，悬浮等）触发，常见的触发的方式有： :hover :focus :checked 媒体查询触发 javascript触发 1234567891011121314div&#123;width:100px;height:100px;background:yellow;transition:width 2s ease-in-out 1.5s;-moz-transition:width 2s ease-in-out 1.5s; /* Firefox 4 */-webkit-transition:width 2s ease-in-out 1.5s; /* Safari and Chrome */-o-transition:width 2s ease-in-out 1.5s; /* Opera */&#125;div:hover&#123;width:300px;&#125; transition的属性 属性 描述 transition-property 执行过渡的css属性 transition-duration 执行过渡的持续时间 transition-timing-function 执行过渡的运动速率曲线 transition-delay 执行过渡的延迟时间 顺带一提transition-property的注意事项，他的可取值如下 none ：没有属性会获得过渡效果。 all ：所有属性都将获得过渡效果。 property ：定义应用过渡效果的 CSS 属性名称列表，以逗号分隔。 不是所有属性都能过渡，只有属性具有一个中间点值才具备过渡效果。完整列表，见这里。 transition的优点在于简单易用，但是它有几个很大的局限。 （1）transition需要事件触发，所以没法在网页加载时自动发生。 （2）transition是一次性的，不能重复发生，除非一再触发。 （3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 （4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。CSS Animation就是为了解决这些问题而提出的。 animation最后来说说最强的animation，animation与keyframes属性搭配使用，有类似flash的概念，animation实现动画效果主要由两部分组成： （1）通过类似Flash动画中的帧来声明一个动画 （2）在animation属性中调用关键帧声明的动画。 关键帧 keyframe 实现自定义动画，通过对关键帧的设定来实现，也就是规定从起始点（0%）到终点（100%）之间的具体节点上的动画样式。就好比一个人起床，睁开眼睛（0%），站起来（10%），穿上衣（40%），穿裤子（80%），整理面容（100%），这样子把每个节点串起来便是动画了。上面提到的transition局限性在于只有两个状态，其实就是相当于只能定义0%和100%。而animation能够自定义任意时间段节点的动画动作。 当在 @keyframes中创建动画时，需要将它捆绑到某个选择器，否则不会产生动画效果。 通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器： 规定动画的名称(animation-name) 规定动画的时长(animation-duration) animation属性类似于transition，都是随着时间改变元素的属性值，其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果。 以下实例为把 “myfirst” 动画捆绑到 div 元素，时长：4 秒，infinite 表示运动次数为无限次，alternate 表示下一周期将逆向地播放。 1234567891011121314151617div&#123;width:100px;height:100px;background:red;animation:myfirst 4s infinite alternate;-moz-animation:myfirst 4s infinite alternate;/* Firefox */-webkit-animation:myfirst 4s infinite alternate; /* Safari and Chrome */-o-animation:myfirst 4s infinite alternate; /* Opera */&#125;@keyframes myfirst&#123;0% &#123;background:red;&#125;50%&#123;background:blue; transform: translate(20px,-20px)&#125;75%&#123;background:green;transform: translate(40px,0px) scale(1.5)&#125;100% &#123;background:yellow;transform: rotate(-45deg)&#125;&#125; 下面的表格列出了 @keyframes 规则和所有动画属性： 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性 animation-name 规定 @keyframes 动画的名称 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的运动速率曲线 animation-delay 规定动画何时开始，默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 animation-fill-mode 规定对象动画时间之外的状态。 参考资料：http://www.w3school.com.cn/css3/css3_animation.asphttp://www.cnblogs.com/aimyfly/p/3195898.htmlhttp://blog.csdn.net/XIAOZHUXMEN/article/details/52003135]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown语法测试1]]></title>
      <url>%2Fgyx1313-blog%2Fmarkdown%2F2016-05-29-%E6%B5%8B%E8%AF%951%2F</url>
      <content type="text"><![CDATA[通过在行首插入 1 到 6 个 # (如#大)，来定义对应的 1 到 6 阶 标题： 大大大在 Markdown 中段落由一行或者多行文本组成，相邻的两行文字会被视为同一段落，如果存在空行则被视为不同段落( Markdown 对空行的定义是看起来是空行就是空行，即使空行中存在 空格 TAB 回车 等不可见字符，同样会被视为空行 )。 第一行 两行之间存在空行，视为不同段落。 链接的语法为[链接名称]然后紧跟（链接） 豆瓣 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://www.douban.com 图片的语法为![图片名称]然后紧跟（图片链接） 倾斜粗体 删除线 这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字这是引用文字 项目 项目 项目 子项目 子项目 项目 * 项目 项目 项目 子项目 子项目 项目 * 列表 属性 描述 苹果 红色 香蕉 黄色 葡萄 紫色 *Hi* 一句话行内代码一句话。 多行代码使用 3 个反引号来标记(反引号一般位于键盘左上角，要用英文) ，在第一个 ｀｀｀ 后面可以跟语言类型，没有语言类型可以省略不写: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export default &#123; [type.ADDEVENT](states, obj)&#123; states.count++; obj.items.id = states.count; states.event.unshift(obj.items); func.local.set(states); &#125;, [type.EVENTDONE](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 2; states.event[i].time = func.getDate(); var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.EVENTTODO](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 1; var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.EVENTCANCEL](states, obj)&#123; for (let i = 0; i &lt; states.event.length; i++) &#123; if (states.event[i].id === obj.id) &#123; states.event[i].type = 3; var item = states.event[i]; states.event.splice(i, 1); break; &#125; &#125; states.event.unshift(item); func.local.set(states); &#125;, [type.CLEAREVENT](states)&#123; states.event = []; func.local.clear(); &#125;, [type.DELEVENT](states, info)&#123; if (states.event[info.index].id === info.id) &#123; states.event.splice(info.index, 1); &#125; else &#123; states.event.filter(function (d, i) &#123; if (d.id == info.id) &#123; states.event.splice(i, 1); &#125; &#125;) &#125; func.local.set(states); &#125;, [type.EDITEVENT](states, info)&#123; if (states.event[info.index].id === info.id) &#123; states.event[info.index].content = info.content; &#125; else &#123; states.event.filter(function (d) &#123; if (d.id == info.id) &#123; d.content = info.content; &#125; &#125;) &#125; func.local.set(states); &#125;&#125; 1$ hexo new "My New Post"]]></content>
    </entry>

    
  
  
</search>
