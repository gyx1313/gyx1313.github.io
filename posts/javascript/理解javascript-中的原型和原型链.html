<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="javascript,基础概念,原型,继承,对象," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="理解对象创建自定义对象最简单的方式就是创建一个Object实例，然后为它添加属性和方法，下面例子是使用Object构造函数创建一个对象：
1234567const person = new Object()person.name = &amp;apos;Trump&amp;apos;person.age = 71person.job = &amp;apos;President&amp;apos;person.sayName =">
<meta property="og:type" content="article">
<meta property="og:title" content="理解javascript 中的原型和原型链还有继承">
<meta property="og:url" content="http://yoursite.com/posts/javascript/理解javascript-中的原型和原型链.html">
<meta property="og:site_name" content="gyx13's blog">
<meta property="og:description" content="理解对象创建自定义对象最简单的方式就是创建一个Object实例，然后为它添加属性和方法，下面例子是使用Object构造函数创建一个对象：
1234567const person = new Object()person.name = &amp;apos;Trump&amp;apos;person.age = 71person.job = &amp;apos;President&amp;apos;person.sayName =">
<meta property="og:image" content="http://www.2cto.com/uploadfile/Collfiles/20141010/20141010081957184.jpg">
<meta property="og:image" content="http://baurine.github.io/assets/images/js-prototype.png">
<meta property="og:image" content="https://www.w3cmm.com/wp-content/uploads/2013/03/prototype-chain-01.png">
<meta property="og:image" content="https://www.w3cmm.com/wp-content/uploads/2013/03/prototype-chain-02.png">
<meta property="og:updated_time" content="2017-09-27T07:11:21.234Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理解javascript 中的原型和原型链还有继承">
<meta name="twitter:description" content="理解对象创建自定义对象最简单的方式就是创建一个Object实例，然后为它添加属性和方法，下面例子是使用Object构造函数创建一个对象：
1234567const person = new Object()person.name = &amp;apos;Trump&amp;apos;person.age = 71person.job = &amp;apos;President&amp;apos;person.sayName =">
<meta name="twitter:image" content="http://www.2cto.com/uploadfile/Collfiles/20141010/20141010081957184.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/posts/javascript/理解javascript-中的原型和原型链.html"/>





  <title> 理解javascript 中的原型和原型链还有继承 | gyx13's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3c91b87c712b0328b52eebe6d21c82a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">gyx13's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">wvwvw</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/javascript/理解javascript-中的原型和原型链.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="gyx13">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gyx13's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                理解javascript 中的原型和原型链还有继承
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-23T20:27:07+08:00">
                2017-09-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/posts/javascript/理解javascript-中的原型和原型链.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>创建自定义对象最简单的方式就是创建一个Object实例，然后为它添加属性和方法，下面例子是使用Object构造函数创建一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person = new Object()</span><br><span class="line">person.name = &apos;Trump&apos;</span><br><span class="line">person.age = 71</span><br><span class="line">person.job = &apos;President&apos;</span><br><span class="line">person.sayName = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子用对象字面量语法可以写成这样：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Trump&apos;,</span><br><span class="line">  age: 71，</span><br><span class="line">  job: &apos;President&apos;,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>虽然Object 构造函数或对象字面量都可以创建单个对象，但是有个明显缺点：使用同一个接口创建很多对象，会产生大量重复代码。为了解决这个问题，人们开始使用工厂模式的一种变体。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createPerson (name, age, job) &#123;</span><br><span class="line">  const o = new Object()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age </span><br><span class="line">  o.job = job </span><br><span class="line">  o.sayName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  return o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = createPerson(&apos;Trump&apos;, 71, &apos;President&apos;)</span><br><span class="line">const person2 = creatPerson(&apos;Bieber&apos;, 23, &apos;wtf&apos;)</span><br></pre></td></tr></table></figure>
<p>函数createPerson() 根据接受的参数来构建一个包含所有必要信息的Person对象。可以无数次调用这个函数，每次都返回一个包含三个属性和一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但是没有解决对象识别的问题（即如何知道一个对象的类型）。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>创建自定义的构造函数，从而定义自定义对象类型的属性和方法。可以使用构造函数模式将上面例子改写成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person (name, age, job) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.job = job</span><br><span class="line">  this.sayName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&apos;Trump&apos;, 71, &apos;President&apos;)</span><br><span class="line">const person2 = new Person(&apos;Bieber&apos;, 23, &apos;wtf&apos;)</span><br></pre></td></tr></table></figure>
<p>Person() 函数与前面的 createPerson() 相比，有以下不同：</p>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了this对象</li>
<li>没有return 语句</li>
</ul>
<p>此外，函数名Person 用的是大写字母P，按照规范，构造函数要以大写字母开头，而非构造函数则以小写字母开头，方便一眼能够以示区分。构造函数本身也是函数，只不过可以用来创建对象。</p>
<p>创建Person的新实例，必须使用new 操作符，这种方式调用构造函数实际上经历的是以下过程：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li>
<li>执行构造函数的代码（为这个新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<p>person1 和person2 分别保存着Person 的一个不同的实例，这两个对象都有一个constructor（构造函数）属性，这个属性指向Person。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1.constructor == Person) // true</span><br><span class="line">console.log(person2.constructor == Person) // true</span><br></pre></td></tr></table></figure>
<p>对象的constructor 属性最初是用来标识对象类型的，如果要检测对象类型，可以用instanceof 操作符。在例子中，所有对象既是Object 的实例，也是Person 的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1 instanceof Person) // true</span><br><span class="line">console.log(person1 instanceof Object) // true</span><br></pre></td></tr></table></figure>
<p>创建自定义构造函数意味着将来可以将它的实例标识为一种特定的类型，而正是构造函数模式比工厂模式更好的地方。person1 和person2 都是Object 的实例，所有对象都是继承自Object。</p>
<p>构造函数的主要问题，是每个方法都要在实例上重新创建一遍。前面例子中，person1 和person2 都有一个名为sayName() 的方法，但两个方法却不是同一个Function 的实例。javascript中，函数即是对象，因此每定义一个函数，就是实例化了一个对象，前面的例子实际上是与以下代码等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person (name, age, job) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.job = job</span><br><span class="line">  this.name = new Function (&apos;console.log(this.name)&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个例子能够更容易明白每个Person 的实例都包含一个不同的Function 实例的本质。所以不同实例上的同名函数是不相等的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1.sayName == person2.sayName) // false</span><br></pre></td></tr></table></figure>
<p>创建两个完成同样任务的Function 实例实在是种浪费，所以我们可以利用原型去解决这个问题。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><strong>每个函数都有一个prototype(原型) 属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</strong>按字面意思理解，prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。也就是不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;Trump&apos;</span><br><span class="line">Person.prototype.age = 71</span><br><span class="line">Person.prototype.job = &apos;President&apos;</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person()</span><br><span class="line">person1.sayName() // &apos;Trump&apos;</span><br><span class="line"></span><br><span class="line">const person2 = new Person()</span><br><span class="line">person2.sayName() // &apos;Trump&apos;</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName == person2.sayName) // true</span><br></pre></td></tr></table></figure>
<p>将sayName() 方法和所有属性添加到了Person 的prototype 属性中，即使构造函数是个空函数，也可以通过调用构造函数来创建新对象，而且新对象还具有相同的属性和方法。并且新对象的这些属性和方法是由所有实例共享的。</p>
<h4 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h4><p>只要创建了一个新函数，该函数就会自动带有prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向指向prototype 所在函数的指针。</p>
<p><img src="http://www.2cto.com/uploadfile/Collfiles/20141010/20141010081957184.jpg" alt="原型链"></p>
<p>创建自定义的构造函数后，其原型对象默认只带有constructor 属性，其他的方法则都是从Object 继承而来的。调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性__proto__，也就是所谓的<strong>隐式原型</strong>(注：图里的[[Prototype]]实际上就是__proto__)</p>
<ul>
<li><strong>总结： __proto__ （隐式原型）属性属于对象，prototpye（显式原型）属性属于构造函数。</strong></li>
</ul>
<p>上图展示了Person 构造函数、Person 的原型属性以及Person现有的两个实例之间的关系。Person.prototype 指向了原型对象，而Person.prototype.constructor 又指回了Person。原型对象中除了包含constructor 属性之外，还包括后来添加的其他属性。Person 的每个实例person1 和person2 都包含一个内部属性，该属性仅仅指向了Person.prototype。换句话说，它们与构造函数没有直接的关系。此外，要注意的是，虽然这两个实例都不包含属性和方法，但却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。</p>
<p>虽然在所有实现中都无法访问到__proto__ ，但可以通过isPrototypeOf() 方法来确定对象之间是否存在这种关系。从本质上讲，如果__proto__ 指向调用isPrototypeOf() 方法的对象（Person.prototype），那么这个方法就返回true，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype.isPrototypeOf(person1)) // true</span><br><span class="line">console.log(Person.prototype.isPrototypeOf(person2)) // true</span><br></pre></td></tr></table></figure>
<p>这里，我们用原型对象的isPrototypeOf() 方法测试了person1 和person2。因为它们内部都有一个指向Person.prototype的指针，因此都返回了true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(person1) == Person.prototype) // true</span><br><span class="line">console.log(Object.getPrototypeOf(person1).name ) // &apos;Trump&apos;</span><br></pre></td></tr></table></figure>
<p>第一行代码只是确定Object.getPrototypeOf() 返回的对象实际就是这个对象的原型。第二行代码取得原型对象中name 属性的值，也就是’Trump’。使用Object.getPrototypeOf() 可以方便地取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。</p>
<p>当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用person1.sayName()的时候，会先后执行两次搜索。首先，解析器会问：“实例person1 有sayName 属性吗？”答：“没有。”然后，它继续搜索，再问：“person1 的原型有sayName 属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。这就是多个对象实例共享原型所保存的属性和方法的基本原理。</p>
<p>尽管可以通过对象实例访问保存在原型的值，但是不能通过对象实例重写原型中的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;Trump&apos;</span><br><span class="line">Person.prototype.age = 71</span><br><span class="line"></span><br><span class="line">const person1 = new Person()</span><br><span class="line">const person2 = new Person()</span><br><span class="line">person1.name = &apos;Hilary&apos;</span><br><span class="line"></span><br><span class="line">console.log(person1.name) // &apos;Hilary&apos; 来自实例</span><br><span class="line">console.log(person2.name) // &apos;Trump&apos; 来自原型</span><br></pre></td></tr></table></figure>
<p>如果在实例添加一个属性，该属性与实例原型中的一个属性同名，那么在实例中创建的该属性就会屏蔽掉原型中的那个同名属性。但访问person1.name 时，因为在实例上就已经找到名为name的属性，所以直接就返回了实例上的name，而没有进一步搜索至原型。以同样方式搜索person2.name，因为实例上没有name属性，所以就搜索至原型的name 属性了。</p>
<p>在实例上添加的属性只会阻止我们访问原型的同名属性，但不会对原型上的属性有所修改。即使在实例上将这个属性设为null，也只是在实例上设置这个属性，而不会恢复其指向原型的链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;Trump&apos;</span><br><span class="line"></span><br><span class="line">const person1 = new Person()</span><br><span class="line">const person2 = new Person()</span><br><span class="line">person1.name = &apos;Hilary&apos;</span><br><span class="line"></span><br><span class="line">console.log(person1.name) // &apos;Hilary&apos; 来自实例</span><br><span class="line">console.log(person2.name) // &apos;Trump&apos; 来自原型</span><br><span class="line"></span><br><span class="line">delete person1.name</span><br><span class="line">console.log(person1.name) // &apos;Trump&apos; 来自原型</span><br></pre></td></tr></table></figure>
<p>不过，使用delete操作符可以完全删除实例属性，从而可以正常重新访问原型属性。</p>
<p>使用hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法只在给定属性存在于对象实例中时，才返回true：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;Trump&apos;</span><br><span class="line"></span><br><span class="line">const person1 = new Person()</span><br><span class="line">console.log(person1.hasOwnProperty(&apos;name&apos;)) // false</span><br><span class="line"></span><br><span class="line">person1.name = &apos;Clinton&apos;</span><br><span class="line">console.log(person1.name) // &apos;Clinton&apos; 来自实例</span><br><span class="line">console.log(person1.hasOwnProperty(&apos;name&apos;)) // true</span><br></pre></td></tr></table></figure>
<h4 id="原型与in-操作符"><a href="#原型与in-操作符" class="headerlink" title="原型与in 操作符"></a>原型与in 操作符</h4><p>有两种方式使用in 操作符，单独使用或在for-in 循环中使用。在单独使用时，in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;Trump&apos;</span><br><span class="line"></span><br><span class="line">const person1 = new Person()</span><br><span class="line">const person2 = new Person()</span><br><span class="line"></span><br><span class="line">console.log(person1.hasOwnProperty(&apos;name&apos;)) // false</span><br><span class="line">console.log(&apos;name&apos; in person1) // true</span><br><span class="line"></span><br><span class="line">person1.name = &apos;Clinton&apos;</span><br><span class="line">console.log(person1.name) // &apos;Clinton&apos; 来自实例</span><br><span class="line">console.log(person1.hasOwnProperty(&apos;name&apos;)) // true</span><br><span class="line">console.log(&apos;name&apos; in person1) // true</span><br><span class="line"></span><br><span class="line">delete person1.name</span><br><span class="line">console.log(person1.name) // &apos;Trump&apos; 来自原型</span><br><span class="line">console.log(person1.hasOwnProperty(&apos;name&apos;)) // false</span><br><span class="line">console.log(&apos;name&apos; in person1) // true</span><br></pre></td></tr></table></figure>
<p>如果同时使用hasOwnProperty() 方法和in 操作符，可以确定该属性到底是存在于实例中还是存在于原型中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function hasPrototypeProperty (obj, name) &#123;</span><br><span class="line">  return !object.hasOwnProperty(name) &amp;&amp; (name in obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;Trump&apos;</span><br><span class="line"></span><br><span class="line">const person1 = new Person()</span><br><span class="line">console.log(hasPrototypeProperty(person1, &apos;name&apos;)) // true</span><br><span class="line"></span><br><span class="line">person1.name = &apos;Clinton&apos;</span><br><span class="line">console.log(hasPrototypeProperty(person1, &apos;name&apos;)) // false</span><br></pre></td></tr></table></figure>
<p>在使用for-in 循环时，返回的是所有能够通过对象访问的，可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记的属性，如一些原生方法等）的实例属性也会在for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const o = &#123;</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return &apos;My Object&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let prop in o) &#123;</span><br><span class="line">  if (prop == &apos;toString&apos;) &#123;</span><br><span class="line">    console.log(&apos;Found toString! &apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象o定义的toString() 方法屏蔽了原型中不可枚举的toString() 方法（原生方法）。因此toString变得可枚举，最后可以成功执行console.log() 。</p>
<p>要取得对象上所有<strong>可枚举的实例属性</strong>，可以用ES5 的<strong>Object.keys() 方法。这个方法接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype.name = &apos;Trump&apos;</span><br><span class="line">Person.prototype.age = 71</span><br><span class="line">Person.prototype.job = &apos;President&apos;</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const keys = Object.keys(Person.prototype)</span><br><span class="line">console.log(keys) // &apos;name, age, job, sayName&apos;</span><br><span class="line"></span><br><span class="line">const p1 = new Person()</span><br><span class="line">p1.name = &apos;Jiang&apos;</span><br><span class="line">p1.age = &apos;999&apos;</span><br><span class="line"></span><br><span class="line">const p1keys = Object.keys(p1)</span><br><span class="line">console.log(p1keys) // &apos;name, age&apos;</span><br></pre></td></tr></table></figure>
<p>如果想要得到所有实例属性，无论是否可枚举，可以使用Object.getOwnPropertyNames() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const keys = Object.getOwnPropertyName(Person.prototype)</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li><p>Object.keys(obj);<strong>返回obj的自身(不包含原型链上的)的所以可枚举属性的名字数组</strong></p>
</li>
<li><p><strong>for in循环则包含原型链</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(name in obj)&#123;</span><br><span class="line">  console.log(name) // 将把自身的属性名和原型链上的属性名挨个输出(只输出可枚举的)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Object.getOwnPropertyNames(obj)，返回obj自身(不含原型链上的)的所有属性名数组，包括不可枚举的。</p>
</li>
<li><p>想要获得原型上的属性信息，使用Object.getPrototypeOf(obj)，先得到原型再操作还有”property” in obj检测属性是否存在，检测所有。包括原型链上的，包括不可枚举的。</p>
</li>
</ul>
<p>参考：<a href="https://www.zhihu.com/question/34733819/" target="_blank" rel="external">https://www.zhihu.com/question/34733819/</a><br><a href="http://www.cnblogs.com/wujie520303/p/4931384.html" target="_blank" rel="external">http://www.cnblogs.com/wujie520303/p/4931384.html</a></p>
<h4 id="原型语法"><a href="#原型语法" class="headerlink" title="原型语法"></a>原型语法</h4><p>前面老是要写一遍Person.prototype 真的有点麻烦，更普遍的写法其实是用包含所有属性和方法的字面量去重写整个原型对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: &apos;Trump&apos;,</span><br><span class="line">  age： 71，</span><br><span class="line">  job: &apos;President&apos;,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码将Person.prototype 设置为等于一个以对象字面量形式创建的新对象，最终结果与前面老是敲Person.prototype 相同，但是！他的constructor 属性不再指向Person 了！因为每创建一个函数，就会同事创建它的prototype对象，这个prototype对象也会自动获得constructor 属性。而这里的语法，本质上完全重写了默认的prototype 对象，所以constructor 属性变成了新对象的constructor 属性，也就是指向了Object 构造函数，不再指向Person 函数。尽管instanceof 操作符还能返回正确的结果，但通过constructor 已经无法确定对象的类型了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 接上面</span><br><span class="line">const nigga = new Person()</span><br><span class="line">console.log(nigga instanceof Object) // true</span><br><span class="line">console.log(nigga instanceof Person) // true</span><br><span class="line">console.log(nigga.constructor == Person) // false</span><br><span class="line">console.log(nigga.constructor == Object) // true</span><br></pre></td></tr></table></figure>
<p>如果要确保constructor 属性一定要指向原来的函数，可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  name: &apos;Trump&apos;,</span><br><span class="line">  age： 71，</span><br><span class="line">  job: &apos;President&apos;,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这样写的话会导致constructor 属性的[[Enumerable]]特性被设置为true，原生的constructor 属性是不可枚举的，想避免这个问题可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: &apos;Trump&apos;,</span><br><span class="line">  age： 71，</span><br><span class="line">  job: &apos;President&apos;,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(Person.prototype, &apos;constructor&apos;, &#123;</span><br><span class="line">  enumerable: false,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const person = new Person()</span><br><span class="line">Person.prototype.sayHi = function() &#123;</span><br><span class="line">  alert(&apos;Hi&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayHi() // &apos;Hi&apos;</span><br></pre></td></tr></table></figure>
<p>初看以上代码会觉得很奇怪，如果是在C或是C++中是不可能在创建对象后还能够在对象创建之后访问类新添加的属性方法。在js中，这个person.sayHi()不仅不会报错反而会正常执行弹出hi的窗口。在内存中，每个对象或是每个实例都通过一个__proto__ 的指针访问相应的property，这有点类似于C++里面的动态调用亦或是动态联编，通过指针来动态的访问内存的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person = new Person()</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor : Person,</span><br><span class="line">  name : &apos;Trump&apos;,</span><br><span class="line">  age : 71,</span><br><span class="line">  sayName ： function() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayName() //error</span><br></pre></td></tr></table></figure>
<p>此处出错的原因在于我们<strong>重写原型后任何原型与之前存在的对象实例之间的关系已经中断</strong>，而它们依然引用的是最初的原型，而最初的原型中不包含sayName（）以及其他重写的属性而是一个Person模型，自然要报错。</p>
<p>上面两段代码有一些说不清道不明的别扭，第一个与第二个的区别在于，第一个里的原型的指针指向是没有变化的，虽然原型增加了新的方法有发展变化，而第二个在完全重写后，先前创建的实例指向的原型没有改变，仍指向原来的原型，后面用对象字面量写法重写原型对象，那就已经不是原来的原型对象，指针指向的地址也必然不一样。有一点必须注意的就是constructor属性是为了确保通过该属性能访问到确切的值。前面提到过，重写默认原型对象造成的结果是constructor属性指向新的原型对象的constructor，即Object。</p>
<h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><p>原型模式的最大问题是其属性都被所有的实例所共享，这种共享对函数来说非常合适，但是对于一些包含引用类型值的属性来说就有问题了，比如数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: &apos;Trump&apos;,</span><br><span class="line">  age： 71，</span><br><span class="line">  job: &apos;President&apos;,</span><br><span class="line">  friends: [&apos;Putin&apos;, &apos;Abe&apos;]</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person()</span><br><span class="line">const person2 = new Person()</span><br><span class="line"></span><br><span class="line">person1.friends.push(&apos;Kim&apos;)</span><br><span class="line">console.log(person1.friends) // &apos;Putin, Abe, Kim&apos;</span><br><span class="line">console.log(person2.friends) // &apos;Putin, Abe, Kim&apos;</span><br><span class="line">console.log(person1.friends === person2.friends) // true</span><br></pre></td></tr></table></figure>
<p>修改person1 的friends 属性，但是person2 的却也受到了影响，因为他们引用的都是同一个来自原型上的数组。下面来看得怎么解决。</p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>为了避免以上提到的问题，在javascript 中我们最常用的是组合使用构造函数模式和原型模式。构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。那么每个实例都会有自己的一份实例属性的副本，但同时又共享着来自原型上的方法，节省了内存。并且还支持向构造函数传递参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.age = age</span><br><span class="line">  this.job = job</span><br><span class="line">  this.friends = [&apos;Putin&apos;, &apos;Abe&apos;]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">  contructor: Person,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&apos;Trump&apos;, 71, &apos;President&apos;)</span><br><span class="line">const person2 = new Person(&apos;Bieber&apos;, 23, &apos;wtf&apos;)</span><br><span class="line">person1.friends.push(&apos;Jiang&apos;)</span><br><span class="line"></span><br><span class="line">console.log(person1.friends) //Putin, Abe, Jiang</span><br><span class="line">console.log(person2.friends) //Putin, Abe</span><br><span class="line"></span><br><span class="line">console.log(person1.friends === person2.friedns) //false</span><br><span class="line">console.log(person1.sayName === person2.sayName) //true</span><br></pre></td></tr></table></figure>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>上面的代码中，构造函数和原型分别独立来定义看起来好像有点奇怪，于是就有了动态原型模式，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下）。可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型，本质上其实跟上面是差不多的，只不过多了个封装，可以在很多jQuery 插件中看到类似的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">  // 属性</span><br><span class="line">  this.name=name</span><br><span class="line">  this.age=age</span><br><span class="line">  this.job=job</span><br><span class="line">  this.friends=[&apos;Putin&apos;,&apos;Abe&apos;]</span><br><span class="line">  // 方法</span><br><span class="line">  if (typeof this.sayName != &apos;function&apos;) &#123;</span><br><span class="line">    Person.prototype.sayName = function () &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const friend = new Person(&apos;Trump&apos;, 71, &apos;President&apos;)</span><br><span class="line">friend.sayName() // &apos;Trump&apos;</span><br></pre></td></tr></table></figure>
<p>这里只在sayName()方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改。其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用instanceof 操作符确定它的类型。</p>
<p>使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</p>
<p>参考：<a href="https://www.zhihu.com/question/41441895/answer/101616119" target="_blank" rel="external">https://www.zhihu.com/question/41441895/answer/101616119</a></p>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>寄生构造函数模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象，表面上看起来是挺像典型的构造函数，但是！实际上其实是工厂模式的一种变体，可以跟前面的工厂模式对比下就明白了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person (name, age, job) &#123;</span><br><span class="line">  const o = new Object()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.job = job</span><br><span class="line">  o.sayName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  return o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = new Person(&apos;Trump&apos;, 71, &apos;President&apos;)</span><br><span class="line">person1.sayName() // Trump</span><br></pre></td></tr></table></figure>
<p>这个模式可以在特殊情况下用来为对象创建构造函数，假如我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array 构造函数，可以使用这个模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray () &#123;</span><br><span class="line">  // 创建数组</span><br><span class="line">  const values = new Array()</span><br><span class="line">  // 添加值</span><br><span class="line">  values.push.apply(value, arguments)</span><br><span class="line">  // 添加方法</span><br><span class="line">  values.toPipedString = function () &#123;</span><br><span class="line">    return this.join(&apos;|&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回数组</span><br><span class="line">  return values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const colors = new SpecialArray(&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;)</span><br><span class="line">console.log(colors.toPipedString()) // &apos;red|blue|green&apos;</span><br></pre></td></tr></table></figure>
<p>利用寄生构造函数模式,在不修改Array构造函数的情况下，通过为Array对象创建构造函数达到修改Array对象的目地。</p>
<p>分析上面的代码：</p>
<ol>
<li>const array = new Array() 创建了一个Array对象</li>
<li>return array 在经过一系列的修改之后返回修改之后的Array对象</li>
<li>const colors = new SpecialArray(“red”,”blue”,”black”) 创建了一个SpecialArray 对象,接收的确是修改之后的Array对象的实例值</li>
</ol>
<p>所以return array 返回的对象是Array类型，而且colors接收了这个返回的对象，所以colors并不是SpecialArray构造函数的实例，而是Array的实例,下面的代码可以说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(colors instanceof SpecialArray) // false</span><br><span class="line">alert(colors instanceof Array) // true</span><br></pre></td></tr></table></figure>
<p>由于存在上述问题，如果能使用其他的模式的情况下，建议不要使用这种模式。</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>所谓<strong>稳妥对象，指的是没有公共属性，而且其方法也不引用this 的对象</strong>。稳妥对象最适合用在一些安全的环境中（这些环境会禁止使用new 和this ），或者防止数据被其他的应用改动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  //创建要返回的对象</span><br><span class="line">  const o = new Object()</span><br><span class="line">  //可以在这里定义私有变量和函数</span><br><span class="line">  //添加方法</span><br><span class="line">  o.sayName = function () &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">  //返回对象</span><br><span class="line">  return o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person = Person(&apos;Trump&apos;, 71)</span><br><span class="line">person.sayName() // 使用稳妥构造函数模式只能通过其构造函数内部的方法来获取里面的属性值</span><br></pre></td></tr></table></figure>
<p>稳妥构造函数与寄生构造函数模式类似，也是跟工厂模式相似，但是也有两点区别：</p>
<ol>
<li><p>稳妥模式不使用new操作符调用构造函数</p>
</li>
<li><p>新创建对象的实例方法不引用this</p>
</li>
</ol>
<p>上面的代码定义了person 变量，里面保存的是一个稳妥对象，而除了吊用他的sayName() 方法外，没有别的方法可以访问其数据成员。即使有其他的代码会给这个对象添加方法和数据成员，但也不可能有别的方法访问到传入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性。使得它非常适合在某些安全执行环境中。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Javascript 的实现继承主要是依靠原型链来实现的，那么什么是原型链？</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="http://baurine.github.io/assets/images/js-prototype.png" alt="原型链"></p>
<p><strong>原型链是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</strong></p>
<p>谨记：每个构造函数都有一个原型对象(.prototype)，原型对象都包含一个指向构造函数的指针(.constructor)，而实例都包含一个指向原型对象的内部指针(.<strong>proto</strong>)。</p>
<p>基本概念：假如我们让原型对象等于另一个类型的实例，那么原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，上述关系依然成立，层层递进构成了实例与原型的链条。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function SuperType () &#123;</span><br><span class="line">  this.property = true</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function () &#123;</span><br><span class="line">  return this.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType () &#123;</span><br><span class="line">  this.subproperty = false</span><br><span class="line">&#125;</span><br><span class="line">// 继承了 SuperType</span><br><span class="line">SubType.prototype = new SuperType()</span><br><span class="line">SubType.prototype.getSubValue = function () &#123;</span><br><span class="line">  return this.subproperty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance = new SubType()</span><br><span class="line">console.log(instance.getSuperValue()) // true</span><br></pre></td></tr></table></figure>
<p>以上代码定义了两个类型：SuperType和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例，换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了，在确立了继承关系之后，我们给SubType.prototype添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。这个例子中的实例以及构造函数和原型之间的关系如图所示：</p>
<p><img src="https://www.w3cmm.com/wp-content/uploads/2013/03/prototype-chain-01.png" alt="SuperTypeSubType"></p>
<p>可以看到在上面的代码中，没有使用SubType 默认的原型，而是换了一个新原型，就是SuperType 的实例。新原型不仅具有作为SuperType 的实例的全部属性和方法，而且内部还有一个指针，指向了SuperType 的原型。最终实际的结果是：instance 指向SubType 的原型，SubType 的原型又指向SuperType 的原型。getSuperValue() 方法仍然还在SuperType.prototype 中，但property 则位于SubType.prototype 中。这是因为property 是一个实例属性，而getSuperValue() 则是一个原型方法。既然SubType.prototype 现在是SuperType 的实例，那么property 当然位于实例中。此外，要注意instance.constructor 现在指向的是SuperType，这是因为原来的SubType.prototype 中的constructor 被重写了的缘故。</p>
<p>通过实现原型链，本质上扩展了原型搜索机制。通过原型链实现继承的情况下，搜索属性过程就是沿着原型链向上。上面的例子中，调用instance.getSuperValue()会经历三个搜索步骤：1)搜索实例；2)搜索SubType.prototype；3)搜索SuperType.prototype，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p>
<h4 id="传说中默认的原型"><a href="#传说中默认的原型" class="headerlink" title="传说中默认的原型"></a>传说中默认的原型</h4><p>不要忘了，<strong>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object 的实例，因此默认原型会包含一个内部指针，指向Object.prototype。</strong>这也正是所有自定义类型都会继承toString()、valueOf() 等默认方法的根本原因。所以，上面例子展现的原型链还应该包括另外一个继承层次：</p>
<p><img src="https://www.w3cmm.com/wp-content/uploads/2013/03/prototype-chain-02.png" alt="SuperTypeSubType"></p>
<p>一句话，SubType继承了SuperType,而SuperType继承了Object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法。</p>
<h4 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h4><p>通过instanceof 操作符可以测试实例与原型的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceof Object)    //true</span><br><span class="line">alert(instance instanceof SuperType) //true</span><br><span class="line">alert(instance instanceof SubType)   //true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.prototype.isPrototypeOf(instance)) // true</span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)) //true</span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)) //true</span><br></pre></td></tr></table></figure>
<h4 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h4><p>子类型有时候需要重写超类型中的某个方法，或者添加超类型中不存在的某个方法。但给原型添加方法的代码一定要放在替换原型的语句之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType () &#123;</span><br><span class="line">  this.property = true</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function () &#123;</span><br><span class="line">  return this.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType () &#123;</span><br><span class="line">  this.subproperty = false</span><br><span class="line">&#125;</span><br><span class="line">// 继承了SuperType</span><br><span class="line">SubType.prototype = new SuperType()</span><br><span class="line">// 添加新方法</span><br><span class="line">SubType.prototype.getSubValue = function () &#123;</span><br><span class="line">  return this.subproperty</span><br><span class="line">&#125;</span><br><span class="line">// 重写超类型中的方法</span><br><span class="line">SubType.prototype.getSuperValue = function () &#123;</span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance = new SubType()</span><br><span class="line">console.log(instance.getSuperValue()) // false</span><br></pre></td></tr></table></figure>
<p>后面注释的两个方法定义。第一个方法getSubValue() 被添加到了SubType 中。第二个方法getSuperValue() 是原型链中已经存在的一个方法，但<strong>重写这个方法将会屏蔽原来的那个方法</strong>。换句话说，当通过SubType 的实例调用getSuperValue() 时，调用的就是这个重新定义的方法；但通过SuperType 的实例调用getSuperValue() 时，还会继续调用原来的那个方法。这里要格外注意的是，必须在用SuperType 的实例替换原型之后，再定义这两个方法。</p>
<p>另外，记得记得不能使用对象字面量去创建原型方法。因为这样会重写原型链！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">  this.property = true</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function() &#123;</span><br><span class="line">  return this.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">  this.subproperty = false</span><br><span class="line">&#125;</span><br><span class="line">//继承了SuperType</span><br><span class="line">SubType.prototype = new SuperType()</span><br><span class="line">//使用字面量添加新方法，会导致上一行代码无效</span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue: function() &#123;</span><br><span class="line">        return this.subproperty</span><br><span class="line">    &#125;,</span><br><span class="line">    someOtherMethod: function() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance = new SubType()</span><br><span class="line">alert(instance.getSuperValue()) // error!</span><br></pre></td></tr></table></figure>
<p>上面的代码展示了刚刚把SuperType的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想中的原型链已经被切断——SubType和SuperType之间已经没有关系了。</p>
<h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><p>原型链的问题来自包含引用类型值的原型。前面提到过，包含引用类型值的原型属性会被所有实例共享，这也正是为什么要在构造函数中，而不是原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是原先的实例属性也就变成了现在的原型属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function SuperType () &#123;</span><br><span class="line">  this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;&#125;</span><br><span class="line">// 继承SuperType</span><br><span class="line">SubType.prototype = new SuperType()</span><br><span class="line"></span><br><span class="line">const instance1 = new SubType()</span><br><span class="line">instance1.colors.push(&apos;black&apos;)</span><br><span class="line">console.log(instance1.colors) // &apos;red, blue, green, black&apos;</span><br><span class="line"></span><br><span class="line">const instance2 = new SubType()</span><br><span class="line">console.log(instance2.colors) // &apos;red, blue, green, black&apos;</span><br></pre></td></tr></table></figure>
<p>原型链的第二个问题是在创建子类型的实例时，不能向超类型的构造函数中传递参数。没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。所以实践中一般很少单独使用原型链，都要用下面的继承方式去解决。</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>借用构造函数，即在子类型的构造函数的内部调用超类型的构造函数。因为函数只不过是在特定环境中执行的代码对象，因此通过使用apply() 和call() 方法可以在将来新创建的对象上执行构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function SuperType () &#123;</span><br><span class="line">  this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">  // 继承SuperType</span><br><span class="line">  SuperType.call(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance1 = new SubType()</span><br><span class="line">instance1.colors.push(&apos;black&apos;)</span><br><span class="line">console.log(instance1.colors) // &apos;red, blue, green, black&apos;</span><br><span class="line"></span><br><span class="line">const instance2 = new SubType()</span><br><span class="line">console.log(instance2.colors) // &apos;red, blue, green&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过使用call()方法（或apply()方法也可以），我们实际上是在将要新创建的SubType 实例的环境下调用了SuperType 构造函数。这样一来，就会在SubType()函数中定义的所有对象初始化代码。每个SubType 的实例就都将具有自己的colors 属性副本了。</p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>借用构造函数另一个优点是可以在子类型构造函数中向超类型构造函数传递参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">  // 继承SuperType 同时传参</span><br><span class="line">  SuperType.call(this, &apos;Trump&apos;)</span><br><span class="line">  this.age = 71</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance = new SubType()</span><br><span class="line">console.log(instance.name) // &apos;Trump&apos;</span><br><span class="line">console.log(instance.age) // 71</span><br></pre></td></tr></table></figure>
<p>为了确保SuperType 构造函数不会重写子类型的属性，可以在调用超类型的构造函数后，再添加应该在子类型中定义的属性。</p>
<h4 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h4><p>借用构造函数无法避免构造函数模式存在的问题——方法不得不都在构造函数中定义，所以函数复用又无从谈起了。而且超类型的原型中定义的方法，对子类型也是不可见的，结果所有类型都只能使用构造函数模式，用例子说话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Parent0()&#123;</span><br><span class="line">  this.name = &quot;parent0&quot;</span><br><span class="line">  this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child0()&#123;</span><br><span class="line">  Parent0.call( this ) // 或apply</span><br><span class="line">  this.type = &quot;child0&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance1 = new Child0() </span><br><span class="line">console.log(instance1.name) // parent0</span><br><span class="line">console.log(instance1.colors) // (3) [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;]</span><br><span class="line"></span><br><span class="line">Parent0.prototype.sex = &quot;男&quot;</span><br><span class="line">Parent0.prototype.say = function() &#123;</span><br><span class="line">  console.log(&quot;Oh, My God! &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance2 = new Child0() </span><br><span class="line">console.log(instance2.sex) // undefined</span><br><span class="line">instance2.say() // Uncaught TypeError: (intermediate value).say is not a function</span><br></pre></td></tr></table></figure>
<p>第6行，在子类（Child0）中执行父类（Parent0）的构造函数，通过这种调用，把父类构造函数的this指向为子类实例化对象引用，从而导致父类执行的时候父类里面的属性都会被挂载到子类的实例上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(instance1 instanceof Child0) // true</span><br><span class="line">console.log(instance1 instanceof Parent0) // false</span><br></pre></td></tr></table></figure>
<p>可以看到，instance1 虽然是子类的实例，但是却不是父类的实例，在创建子类实例的过程中，借用构造函数仅仅是将父类实例上属性和方法“附上”、“注入”进子类实例，子类实例并不是真正的父类实例，所以父类原型上的东西也没法继承的，因此并没有真正的实现继承（部分继承）。</p>
<h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>组合继承，是将原型链和借用构造函数结合在一起，汲取了两个方式的优点。基本思想是<strong>使用原型链实现对原型属性和方法的继承，然后再通过借用构造函数来实现对实例属性的继承。</strong>既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function SuperType (name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType (name, age) &#123;</span><br><span class="line">  // 继承属性</span><br><span class="line">  SuperType.call(this, name)</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">// 继承方法</span><br><span class="line">SubType.prototype = new SuperType()</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">  console.log(this.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance1 = newSubType(&apos;Trump&apos;, 71)</span><br><span class="line">instance.colors.push(&apos;black&apos;)</span><br><span class="line">console.log(instance1.colors) // &apos;red, blue, green, black&apos;</span><br><span class="line">instance1.sayName() // &apos;Trump&apos;</span><br><span class="line">instance1.sayAge() // 71</span><br><span class="line"></span><br><span class="line">const instance2 = newSubType(&apos;Kim&apos;, 33)</span><br><span class="line">console.log(instance1.colors) // &apos;red, blue, green&apos;</span><br><span class="line">instance1.sayName() // &apos;Kim&apos;</span><br><span class="line">instance1.sayAge() // 33</span><br></pre></td></tr></table></figure>
<p>上面的代码，Supertype 构造函数定义了name 和colors 两个属性，SuperType 的原型定义了一个方法sayName()。SubType 构造函数在调用SuperType 构造函数时传入了name 参数，然后又定义了自己的属性age。然后再将SuperType 的实例赋值给SubType 的原型，然后又在该新原型上定义了方法sayAge()。这样，可以让不同的SubType 实例分别拥有自己的属性，又拥有相同的方法（来自SuperType 原型）。组合继承是javascript中最常用的继承模式，而且instanceof 和isPrototypeOf() 也能用于识别组合继承模式创建的对象。</p>
<p>要说缺点。父类的构造函数被执行了两次，第一次是SubType.prototype = new SuperType()，第二次是在实例化时，借用构造函数的时候，后面覆盖了前面的，这是没有必要的。</p>
<h4 id="寄生组合式继承（组合式继承优化）"><a href="#寄生组合式继承（组合式继承优化）" class="headerlink" title="寄生组合式继承（组合式继承优化）"></a>寄生组合式继承（组合式继承优化）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function SuperType (name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType (name, age) &#123;</span><br><span class="line">  // 继承属性</span><br><span class="line">  SuperType.call(this, name)</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">// 继承方法的优化</span><br><span class="line">SubType.prototype = Object.create(SuperType.prototype)</span><br><span class="line">SubType.prototype.constructor = Subtype</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">  console.log(this.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const instance1 = newSubType(&apos;Trump&apos;, 71)</span><br><span class="line">instance.colors.push(&apos;black&apos;)</span><br><span class="line">console.log(instance1.colors) // &apos;red, blue, green, black&apos;</span><br><span class="line">instance1.sayName() // &apos;Trump&apos;</span><br><span class="line">instance1.sayAge() // 71</span><br><span class="line"></span><br><span class="line">const instance2 = newSubType(&apos;Kim&apos;, 33)</span><br><span class="line">console.log(instance1.colors) // &apos;red, blue, green&apos;</span><br><span class="line">instance1.sayName() // &apos;Kim&apos;</span><br><span class="line">instance1.sayAge() // 33</span><br></pre></td></tr></table></figure>
<p>这里的关键在于，我们把之前的<code>SubType.prototype = new SuperType()</code> 改成了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SubType.prototype = Object.create(SuperType.prototype)</span><br><span class="line">SubType.prototype.constructor = SubType</span><br></pre></td></tr></table></figure>
<p>因为这样改写SubType.prototype 跟用对象字面量改写一样会导致原型丢失，所以需要对constructor 做重新指定。</p>
<p>Object.create是一种创建对象的方式，它会创建一个中间对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const p = &#123;name: &quot;p&quot;&#125;</span><br><span class="line">const obj = Object.create(p) // Object.create(&#123; name: &quot;p&quot; &#125;)</span><br></pre></td></tr></table></figure>
<p>通过这种方式创建对象，新创建的对象obj的原型就是p，同时obj也拥有了属性name，这个新创建的中间对象的原型对象就是它的参数。</p>
<p>寄生组合式继承只调用了一次SuperType 的构造函数，并且因此避免了在SubType.prototype 上面创建不必要的多余属性。同时原型链还能保持不变，所以寄生组合式继承可以说是最理想的继承方式了。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>原型式继承是指借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fuction object (o) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1 = &#123;</span><br><span class="line">  name: &apos;Trump&apos;,</span><br><span class="line">  friends: [&apos;Putin&apos;, &apos;Abe&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person2 = object(person1)</span><br><span class="line">person2.name = &apos;Kim&apos;</span><br><span class="line">person2.friends.push(&apos;Jiang&apos;)</span><br><span class="line">console.log(person1.friends) // &apos;Putin&apos;, &apos;Abe&apos;, &apos;Jiang&apos;</span><br><span class="line"></span><br><span class="line">const person3 = object(person1)</span><br><span class="line">person3.name = &apos;Macron&apos;</span><br><span class="line">person3.friends.push(&apos;Merkel&apos;)</span><br><span class="line">console.log(person1.friends) // &apos;Putin, Abe, Jiang, Merkel&apos;</span><br></pre></td></tr></table></figure>
<p>原型式继承的核心是，必须以一个对象作为新对象的基础，以上的代码，将person1 这个对象传进object() 函数中，在创建person2和person3的过程中，都是person1 将作为对象基础，然后再被返回出来。因为新对象是以person1 作为原型，所以他们原型上就包含了person1 的基本类型值属性(name)和引用类型值属性(friends)。person1.friends 也将被person2 和person3 共有，可以看到在person2 和person3 对friends 做的修改在person1 也体现出来了。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承与寄生构造函数和工厂模式类似，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 接上面的object()函数</span><br><span class="line">function createAnother (original) &#123;</span><br><span class="line">  const clone = object(original)</span><br><span class="line">  clone.sayHi = function () &#123;</span><br><span class="line">    console.log(&apos;hi&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  return clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，createAnother() 函数接受一个参数，也就是将要作为新对象基础的对象。然后把这个对象传递给object() 函数，将返回的结果赋给clone。再为clone 对象添加新方法sayHi()，最后返回clone 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 接上面</span><br><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Trump&apos;,</span><br><span class="line">  friends: [&apos;Putin&apos;, &apos;Abe&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHi()</span><br></pre></td></tr></table></figure>
<p>在这里，新对象anotherPerson 具有person 的所有属性和方法，而且还有自己的sayHi() 方法。</p>
<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式，上述代码中使用的object() 函数不是必须的，任何能够返回新对象的函数都适用此模式。缺点就是使用寄生式继承为对象添加的函数，还是做不到函数复用。</p>
<h3 id="ES6的继承"><a href="#ES6的继承" class="headerlink" title="ES6的继承"></a>ES6的继承</h3><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Child1 extends Parent &#123;</span><br><span class="line">  constructor(x, y, colors) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.colors = colors;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.colors + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。如果子类没有定义constructor方法，这个方法会被默认添加，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>参考： <a href="https://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;mid=2676491918&amp;idx=1&amp;sn=2a30b02356595e974537c78b2a82f8eb" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;mid=2676491918&amp;idx=1&amp;sn=2a30b02356595e974537c78b2a82f8eb</a></p>
<p><a href="http://www.jianshu.com/p/3c2333034429" target="_blank" rel="external">http://www.jianshu.com/p/3c2333034429</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
            <a href="/tags/基础概念/" rel="tag"># 基础概念</a>
          
            <a href="/tags/原型/" rel="tag"># 原型</a>
          
            <a href="/tags/继承/" rel="tag"># 继承</a>
          
            <a href="/tags/对象/" rel="tag"># 对象</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/javascript/作用域与闭包详解.html" rel="next" title="作用域与闭包详解">
                <i class="fa fa-chevron-left"></i> 作用域与闭包详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="gyx13" />
          <p class="site-author-name" itemprop="name">gyx13</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#理解对象"><span class="nav-number">1.</span> <span class="nav-text">理解对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建对象"><span class="nav-number">2.</span> <span class="nav-text">创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂模式"><span class="nav-number">2.1.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数模式"><span class="nav-number">2.2.</span> <span class="nav-text">构造函数模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型模式"><span class="nav-number">2.3.</span> <span class="nav-text">原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#理解原型对象"><span class="nav-number">2.3.1.</span> <span class="nav-text">理解原型对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型与in-操作符"><span class="nav-number">2.3.2.</span> <span class="nav-text">原型与in 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型语法"><span class="nav-number">2.3.3.</span> <span class="nav-text">原型语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型的动态性"><span class="nav-number">2.3.4.</span> <span class="nav-text">原型的动态性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型对象的问题"><span class="nav-number">2.3.5.</span> <span class="nav-text">原型对象的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合使用构造函数模式和原型模式"><span class="nav-number">2.4.</span> <span class="nav-text">组合使用构造函数模式和原型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态原型模式"><span class="nav-number">2.5.</span> <span class="nav-text">动态原型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄生构造函数模式"><span class="nav-number">2.6.</span> <span class="nav-text">寄生构造函数模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#稳妥构造函数模式"><span class="nav-number">2.7.</span> <span class="nav-text">稳妥构造函数模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">3.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链"><span class="nav-number">3.1.</span> <span class="nav-text">原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传说中默认的原型"><span class="nav-number">3.1.1.</span> <span class="nav-text">传说中默认的原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#确定原型和实例的关系"><span class="nav-number">3.1.2.</span> <span class="nav-text">确定原型和实例的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#谨慎地定义方法"><span class="nav-number">3.1.3.</span> <span class="nav-text">谨慎地定义方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链的问题"><span class="nav-number">3.1.4.</span> <span class="nav-text">原型链的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#借用构造函数"><span class="nav-number">3.2.</span> <span class="nav-text">借用构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传递参数"><span class="nav-number">3.2.1.</span> <span class="nav-text">传递参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#借用构造函数的问题"><span class="nav-number">3.2.2.</span> <span class="nav-text">借用构造函数的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合式继承"><span class="nav-number">3.3.</span> <span class="nav-text">组合式继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#寄生组合式继承（组合式继承优化）"><span class="nav-number">3.3.1.</span> <span class="nav-text">寄生组合式继承（组合式继承优化）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型式继承"><span class="nav-number">3.4.</span> <span class="nav-text">原型式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄生式继承"><span class="nav-number">3.5.</span> <span class="nav-text">寄生式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6的继承"><span class="nav-number">3.6.</span> <span class="nav-text">ES6的继承</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gyx13</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "a40f22b58f5247488b626b07419b669f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  







  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="local-search-pop-overlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


  

</body>
</html>
